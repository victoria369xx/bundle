/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./js/calcDatesDiff.js":
/*!*****************************!*\
  !*** ./js/calcDatesDiff.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _luxonSrc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./luxonSrc */ \"./js/luxonSrc.js\");\n\r\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(dateFromStr, dateToStr){\r\n    if (dateFromStr < dateToStr){\r\n        [dateFromStr, dateToStr] = [dateToStr, dateFromStr]\r\n    }\r\n\r\n    const dateFrom = _luxonSrc__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(dateFromStr);\r\n    const dateTo = _luxonSrc__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(dateToStr);\r\n\r\n    const diff = dateFrom.diff(dateTo, ['years', 'months', 'days']).toObject();\r\n\r\n    return diff\r\n}\n\n//# sourceURL=webpack://hw2/./js/calcDatesDiff.js?");

/***/ }),

/***/ "./js/howler.js":
/*!**********************!*\
  !*** ./js/howler.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"sound\": () => (/* binding */ sound)\n/* harmony export */ });\n/* harmony import */ var _howlerSrc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./howlerSrc.js */ \"./js/howlerSrc.js\");\n \r\n\r\n\r\nvar sound = new Howl ({\r\n    src: ['../sound.wav']\r\n})\r\n\r\n\n\n//# sourceURL=webpack://hw2/./js/howler.js?");

/***/ }),

/***/ "./js/howlerSrc.js":
/*!*************************!*\
  !*** ./js/howlerSrc.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HowlToExport\": () => (/* binding */ HowlToExport)\n/* harmony export */ });\nlet HowlToExport; \r\n/*!\r\n *  howler.js v2.2.3\r\n *  howlerjs.com\r\n *\r\n *  (c) 2013-2020, James Simpson of GoldFire Studios\r\n *  goldfirestudios.com\r\n *\r\n *  MIT License\r\n */\r\n\r\n(function() {\r\n\r\n    'use strict';\r\n  \r\n    /** Global Methods **/\r\n    /***************************************************************************/\r\n  \r\n    /**\r\n     * Create the global controller. All contained methods and properties apply\r\n     * to all sounds that are currently playing or will be in the future.\r\n     */\r\n    var HowlerGlobal = function() {\r\n      this.init();\r\n    };\r\n    HowlerGlobal.prototype = {\r\n      /**\r\n       * Initialize the global Howler object.\r\n       * @return {Howler}\r\n       */\r\n      init: function() {\r\n        var self = this || Howler;\r\n  \r\n        // Create a global ID counter.\r\n        self._counter = 1000;\r\n  \r\n        // Pool of unlocked HTML5 Audio objects.\r\n        self._html5AudioPool = [];\r\n        self.html5PoolSize = 10;\r\n  \r\n        // Internal properties.\r\n        self._codecs = {};\r\n        self._howls = [];\r\n        self._muted = false;\r\n        self._volume = 1;\r\n        self._canPlayEvent = 'canplaythrough';\r\n        self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;\r\n  \r\n        // Public properties.\r\n        self.masterGain = null;\r\n        self.noAudio = false;\r\n        self.usingWebAudio = true;\r\n        self.autoSuspend = true;\r\n        self.ctx = null;\r\n  \r\n        // Set to false to disable the auto audio unlocker.\r\n        self.autoUnlock = true;\r\n  \r\n        // Setup the various state values for global tracking.\r\n        self._setup();\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Get/set the global volume for all sounds.\r\n       * @param  {Float} vol Volume from 0.0 to 1.0.\r\n       * @return {Howler/Float}     Returns self or current volume.\r\n       */\r\n      volume: function(vol) {\r\n        var self = this || Howler;\r\n        vol = parseFloat(vol);\r\n  \r\n        // If we don't have an AudioContext created yet, run the setup.\r\n        if (!self.ctx) {\r\n          setupAudioContext();\r\n        }\r\n  \r\n        if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\r\n          self._volume = vol;\r\n  \r\n          // Don't update any of the nodes if we are muted.\r\n          if (self._muted) {\r\n            return self;\r\n          }\r\n  \r\n          // When using Web Audio, we just need to adjust the master gain.\r\n          if (self.usingWebAudio) {\r\n            self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);\r\n          }\r\n  \r\n          // Loop through and change volume for all HTML5 audio nodes.\r\n          for (var i=0; i<self._howls.length; i++) {\r\n            if (!self._howls[i]._webAudio) {\r\n              // Get all of the sounds in this Howl group.\r\n              var ids = self._howls[i]._getSoundIds();\r\n  \r\n              // Loop through all sounds and change the volumes.\r\n              for (var j=0; j<ids.length; j++) {\r\n                var sound = self._howls[i]._soundById(ids[j]);\r\n  \r\n                if (sound && sound._node) {\r\n                  sound._node.volume = sound._volume * vol;\r\n                }\r\n              }\r\n            }\r\n          }\r\n  \r\n          return self;\r\n        }\r\n  \r\n        return self._volume;\r\n      },\r\n  \r\n      /**\r\n       * Handle muting and unmuting globally.\r\n       * @param  {Boolean} muted Is muted or not.\r\n       */\r\n      mute: function(muted) {\r\n        var self = this || Howler;\r\n  \r\n        // If we don't have an AudioContext created yet, run the setup.\r\n        if (!self.ctx) {\r\n          setupAudioContext();\r\n        }\r\n  \r\n        self._muted = muted;\r\n  \r\n        // With Web Audio, we just need to mute the master gain.\r\n        if (self.usingWebAudio) {\r\n          self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);\r\n        }\r\n  \r\n        // Loop through and mute all HTML5 Audio nodes.\r\n        for (var i=0; i<self._howls.length; i++) {\r\n          if (!self._howls[i]._webAudio) {\r\n            // Get all of the sounds in this Howl group.\r\n            var ids = self._howls[i]._getSoundIds();\r\n  \r\n            // Loop through all sounds and mark the audio node as muted.\r\n            for (var j=0; j<ids.length; j++) {\r\n              var sound = self._howls[i]._soundById(ids[j]);\r\n  \r\n              if (sound && sound._node) {\r\n                sound._node.muted = (muted) ? true : sound._muted;\r\n              }\r\n            }\r\n          }\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Handle stopping all sounds globally.\r\n       */\r\n      stop: function() {\r\n        var self = this || Howler;\r\n  \r\n        // Loop through all Howls and stop them.\r\n        for (var i=0; i<self._howls.length; i++) {\r\n          self._howls[i].stop();\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Unload and destroy all currently loaded Howl objects.\r\n       * @return {Howler}\r\n       */\r\n      unload: function() {\r\n        var self = this || Howler;\r\n  \r\n        for (var i=self._howls.length-1; i>=0; i--) {\r\n          self._howls[i].unload();\r\n        }\r\n  \r\n        // Create a new AudioContext to make sure it is fully reset.\r\n        if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {\r\n          self.ctx.close();\r\n          self.ctx = null;\r\n          setupAudioContext();\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Check for codec support of specific extension.\r\n       * @param  {String} ext Audio file extention.\r\n       * @return {Boolean}\r\n       */\r\n      codecs: function(ext) {\r\n        return (this || Howler)._codecs[ext.replace(/^x-/, '')];\r\n      },\r\n  \r\n      /**\r\n       * Setup various state values for global tracking.\r\n       * @return {Howler}\r\n       */\r\n      _setup: function() {\r\n        var self = this || Howler;\r\n  \r\n        // Keeps track of the suspend/resume state of the AudioContext.\r\n        self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';\r\n  \r\n        // Automatically begin the 30-second suspend process\r\n        self._autoSuspend();\r\n  \r\n        // Check if audio is available.\r\n        if (!self.usingWebAudio) {\r\n          // No audio is available on this system if noAudio is set to true.\r\n          if (typeof Audio !== 'undefined') {\r\n            try {\r\n              var test = new Audio();\r\n  \r\n              // Check if the canplaythrough event is available.\r\n              if (typeof test.oncanplaythrough === 'undefined') {\r\n                self._canPlayEvent = 'canplay';\r\n              }\r\n            } catch(e) {\r\n              self.noAudio = true;\r\n            }\r\n          } else {\r\n            self.noAudio = true;\r\n          }\r\n        }\r\n  \r\n        // Test to make sure audio isn't disabled in Internet Explorer.\r\n        try {\r\n          var test = new Audio();\r\n          if (test.muted) {\r\n            self.noAudio = true;\r\n          }\r\n        } catch (e) {}\r\n  \r\n        // Check for supported codecs.\r\n        if (!self.noAudio) {\r\n          self._setupCodecs();\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Check for browser support for various codecs and cache the results.\r\n       * @return {Howler}\r\n       */\r\n      _setupCodecs: function() {\r\n        var self = this || Howler;\r\n        var audioTest = null;\r\n  \r\n        // Must wrap in a try/catch because IE11 in server mode throws an error.\r\n        try {\r\n          audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;\r\n        } catch (err) {\r\n          return self;\r\n        }\r\n  \r\n        if (!audioTest || typeof audioTest.canPlayType !== 'function') {\r\n          return self;\r\n        }\r\n  \r\n        var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');\r\n  \r\n        // Opera version <33 has mixed MP3 support, so we need to check for and block it.\r\n        var ua = self._navigator ? self._navigator.userAgent : '';\r\n        var checkOpera = ua.match(/OPR\\/([0-6].)/g);\r\n        var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);\r\n        var checkSafari = ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1;\r\n        var safariVersion = ua.match(/Version\\/(.*?) /);\r\n        var isOldSafari = (checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15);\r\n  \r\n        self._codecs = {\r\n          mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),\r\n          mpeg: !!mpegTest,\r\n          opus: !!audioTest.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, ''),\r\n          ogg: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\r\n          oga: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\r\n          wav: !!(audioTest.canPlayType('audio/wav; codecs=\"1\"') || audioTest.canPlayType('audio/wav')).replace(/^no$/, ''),\r\n          aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),\r\n          caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),\r\n          m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\r\n          m4b: !!(audioTest.canPlayType('audio/x-m4b;') || audioTest.canPlayType('audio/m4b;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\r\n          mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\r\n          weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\r\n          webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\r\n          dolby: !!audioTest.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, ''),\r\n          flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')\r\n        };\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Some browsers/devices will only allow audio to be played after a user interaction.\r\n       * Attempt to automatically unlock audio on the first user interaction.\r\n       * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/\r\n       * @return {Howler}\r\n       */\r\n      _unlockAudio: function() {\r\n        var self = this || Howler;\r\n  \r\n        // Only run this if Web Audio is supported and it hasn't already been unlocked.\r\n        if (self._audioUnlocked || !self.ctx) {\r\n          return;\r\n        }\r\n  \r\n        self._audioUnlocked = false;\r\n        self.autoUnlock = false;\r\n  \r\n        // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.\r\n        // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.\r\n        // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.\r\n        if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {\r\n          self._mobileUnloaded = true;\r\n          self.unload();\r\n        }\r\n  \r\n        // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:\r\n        // http://stackoverflow.com/questions/24119684\r\n        self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);\r\n  \r\n        // Call this method on touch start to create and play a buffer,\r\n        // then check if the audio actually played to determine if\r\n        // audio has now been unlocked on iOS, Android, etc.\r\n        var unlock = function(e) {\r\n          // Create a pool of unlocked HTML5 Audio objects that can\r\n          // be used for playing sounds without user interaction. HTML5\r\n          // Audio objects must be individually unlocked, as opposed\r\n          // to the WebAudio API which only needs a single activation.\r\n          // This must occur before WebAudio setup or the source.onended\r\n          // event will not fire.\r\n          while (self._html5AudioPool.length < self.html5PoolSize) {\r\n            try {\r\n              var audioNode = new Audio();\r\n  \r\n              // Mark this Audio object as unlocked to ensure it can get returned\r\n              // to the unlocked pool when released.\r\n              audioNode._unlocked = true;\r\n  \r\n              // Add the audio node to the pool.\r\n              self._releaseHtml5Audio(audioNode);\r\n            } catch (e) {\r\n              self.noAudio = true;\r\n              break;\r\n            }\r\n          }\r\n  \r\n          // Loop through any assigned audio nodes and unlock them.\r\n          for (var i=0; i<self._howls.length; i++) {\r\n            if (!self._howls[i]._webAudio) {\r\n              // Get all of the sounds in this Howl group.\r\n              var ids = self._howls[i]._getSoundIds();\r\n  \r\n              // Loop through all sounds and unlock the audio nodes.\r\n              for (var j=0; j<ids.length; j++) {\r\n                var sound = self._howls[i]._soundById(ids[j]);\r\n  \r\n                if (sound && sound._node && !sound._node._unlocked) {\r\n                  sound._node._unlocked = true;\r\n                  sound._node.load();\r\n                }\r\n              }\r\n            }\r\n          }\r\n  \r\n          // Fix Android can not play in suspend state.\r\n          self._autoResume();\r\n  \r\n          // Create an empty buffer.\r\n          var source = self.ctx.createBufferSource();\r\n          source.buffer = self._scratchBuffer;\r\n          source.connect(self.ctx.destination);\r\n  \r\n          // Play the empty buffer.\r\n          if (typeof source.start === 'undefined') {\r\n            source.noteOn(0);\r\n          } else {\r\n            source.start(0);\r\n          }\r\n  \r\n          // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.\r\n          if (typeof self.ctx.resume === 'function') {\r\n            self.ctx.resume();\r\n          }\r\n  \r\n          // Setup a timeout to check that we are unlocked on the next event loop.\r\n          source.onended = function() {\r\n            source.disconnect(0);\r\n  \r\n            // Update the unlocked state and prevent this check from happening again.\r\n            self._audioUnlocked = true;\r\n  \r\n            // Remove the touch start listener.\r\n            document.removeEventListener('touchstart', unlock, true);\r\n            document.removeEventListener('touchend', unlock, true);\r\n            document.removeEventListener('click', unlock, true);\r\n            document.removeEventListener('keydown', unlock, true);\r\n  \r\n            // Let all sounds know that audio has been unlocked.\r\n            for (var i=0; i<self._howls.length; i++) {\r\n              self._howls[i]._emit('unlock');\r\n            }\r\n          };\r\n        };\r\n  \r\n        // Setup a touch start listener to attempt an unlock in.\r\n        document.addEventListener('touchstart', unlock, true);\r\n        document.addEventListener('touchend', unlock, true);\r\n        document.addEventListener('click', unlock, true);\r\n        document.addEventListener('keydown', unlock, true);\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Get an unlocked HTML5 Audio object from the pool. If none are left,\r\n       * return a new Audio object and throw a warning.\r\n       * @return {Audio} HTML5 Audio object.\r\n       */\r\n      _obtainHtml5Audio: function() {\r\n        var self = this || Howler;\r\n  \r\n        // Return the next object from the pool if one exists.\r\n        if (self._html5AudioPool.length) {\r\n          return self._html5AudioPool.pop();\r\n        }\r\n  \r\n        //.Check if the audio is locked and throw a warning.\r\n        var testPlay = new Audio().play();\r\n        if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {\r\n          testPlay.catch(function() {\r\n            console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');\r\n          });\r\n        }\r\n  \r\n        return new Audio();\r\n      },\r\n  \r\n      /**\r\n       * Return an activated HTML5 Audio object to the pool.\r\n       * @return {Howler}\r\n       */\r\n      _releaseHtml5Audio: function(audio) {\r\n        var self = this || Howler;\r\n  \r\n        // Don't add audio to the pool if we don't know if it has been unlocked.\r\n        if (audio._unlocked) {\r\n          self._html5AudioPool.push(audio);\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.\r\n       * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.\r\n       * @return {Howler}\r\n       */\r\n      _autoSuspend: function() {\r\n        var self = this;\r\n  \r\n        if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {\r\n          return;\r\n        }\r\n  \r\n        // Check if any sounds are playing.\r\n        for (var i=0; i<self._howls.length; i++) {\r\n          if (self._howls[i]._webAudio) {\r\n            for (var j=0; j<self._howls[i]._sounds.length; j++) {\r\n              if (!self._howls[i]._sounds[j]._paused) {\r\n                return self;\r\n              }\r\n            }\r\n          }\r\n        }\r\n  \r\n        if (self._suspendTimer) {\r\n          clearTimeout(self._suspendTimer);\r\n        }\r\n  \r\n        // If no sound has played after 30 seconds, suspend the context.\r\n        self._suspendTimer = setTimeout(function() {\r\n          if (!self.autoSuspend) {\r\n            return;\r\n          }\r\n  \r\n          self._suspendTimer = null;\r\n          self.state = 'suspending';\r\n  \r\n          // Handle updating the state of the audio context after suspending.\r\n          var handleSuspension = function() {\r\n            self.state = 'suspended';\r\n  \r\n            if (self._resumeAfterSuspend) {\r\n              delete self._resumeAfterSuspend;\r\n              self._autoResume();\r\n            }\r\n          };\r\n  \r\n          // Either the state gets suspended or it is interrupted.\r\n          // Either way, we need to update the state to suspended.\r\n          self.ctx.suspend().then(handleSuspension, handleSuspension);\r\n        }, 30000);\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Automatically resume the Web Audio AudioContext when a new sound is played.\r\n       * @return {Howler}\r\n       */\r\n      _autoResume: function() {\r\n        var self = this;\r\n  \r\n        if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {\r\n          return;\r\n        }\r\n  \r\n        if (self.state === 'running' && self.ctx.state !== 'interrupted' && self._suspendTimer) {\r\n          clearTimeout(self._suspendTimer);\r\n          self._suspendTimer = null;\r\n        } else if (self.state === 'suspended' || self.state === 'running' && self.ctx.state === 'interrupted') {\r\n          self.ctx.resume().then(function() {\r\n            self.state = 'running';\r\n  \r\n            // Emit to all Howls that the audio has resumed.\r\n            for (var i=0; i<self._howls.length; i++) {\r\n              self._howls[i]._emit('resume');\r\n            }\r\n          });\r\n  \r\n          if (self._suspendTimer) {\r\n            clearTimeout(self._suspendTimer);\r\n            self._suspendTimer = null;\r\n          }\r\n        } else if (self.state === 'suspending') {\r\n          self._resumeAfterSuspend = true;\r\n        }\r\n  \r\n        return self;\r\n      }\r\n    };\r\n  \r\n    // Setup the global audio controller.\r\n    var Howler = new HowlerGlobal();\r\n  \r\n    /** Group Methods **/\r\n    /***************************************************************************/\r\n  \r\n    /**\r\n     * Create an audio group controller.\r\n     * @param {Object} o Passed in properties for this group.\r\n     */\r\n    var Howl = function(o) {\r\n      var self = this;\r\n  \r\n      // Throw an error if no source is provided.\r\n      if (!o.src || o.src.length === 0) {\r\n        console.error('An array of source files must be passed with any new Howl.');\r\n        return;\r\n      }\r\n  \r\n      self.init(o);\r\n    };\r\n    Howl.prototype = {\r\n      /**\r\n       * Initialize a new Howl group object.\r\n       * @param  {Object} o Passed in properties for this group.\r\n       * @return {Howl}\r\n       */\r\n      init: function(o) {\r\n        var self = this;\r\n  \r\n        // If we don't have an AudioContext created yet, run the setup.\r\n        if (!Howler.ctx) {\r\n          setupAudioContext();\r\n        }\r\n  \r\n        // Setup user-defined default properties.\r\n        self._autoplay = o.autoplay || false;\r\n        self._format = (typeof o.format !== 'string') ? o.format : [o.format];\r\n        self._html5 = o.html5 || false;\r\n        self._muted = o.mute || false;\r\n        self._loop = o.loop || false;\r\n        self._pool = o.pool || 5;\r\n        self._preload = (typeof o.preload === 'boolean' || o.preload === 'metadata') ? o.preload : true;\r\n        self._rate = o.rate || 1;\r\n        self._sprite = o.sprite || {};\r\n        self._src = (typeof o.src !== 'string') ? o.src : [o.src];\r\n        self._volume = o.volume !== undefined ? o.volume : 1;\r\n        self._xhr = {\r\n          method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',\r\n          headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,\r\n          withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false,\r\n        };\r\n  \r\n        // Setup all other default properties.\r\n        self._duration = 0;\r\n        self._state = 'unloaded';\r\n        self._sounds = [];\r\n        self._endTimers = {};\r\n        self._queue = [];\r\n        self._playLock = false;\r\n  \r\n        // Setup event listeners.\r\n        self._onend = o.onend ? [{fn: o.onend}] : [];\r\n        self._onfade = o.onfade ? [{fn: o.onfade}] : [];\r\n        self._onload = o.onload ? [{fn: o.onload}] : [];\r\n        self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];\r\n        self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];\r\n        self._onpause = o.onpause ? [{fn: o.onpause}] : [];\r\n        self._onplay = o.onplay ? [{fn: o.onplay}] : [];\r\n        self._onstop = o.onstop ? [{fn: o.onstop}] : [];\r\n        self._onmute = o.onmute ? [{fn: o.onmute}] : [];\r\n        self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];\r\n        self._onrate = o.onrate ? [{fn: o.onrate}] : [];\r\n        self._onseek = o.onseek ? [{fn: o.onseek}] : [];\r\n        self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];\r\n        self._onresume = [];\r\n  \r\n        // Web Audio or HTML5 Audio?\r\n        self._webAudio = Howler.usingWebAudio && !self._html5;\r\n  \r\n        // Automatically try to enable audio.\r\n        if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {\r\n          Howler._unlockAudio();\r\n        }\r\n  \r\n        // Keep track of this Howl group in the global controller.\r\n        Howler._howls.push(self);\r\n  \r\n        // If they selected autoplay, add a play event to the load queue.\r\n        if (self._autoplay) {\r\n          self._queue.push({\r\n            event: 'play',\r\n            action: function() {\r\n              self.play();\r\n            }\r\n          });\r\n        }\r\n  \r\n        // Load the source file unless otherwise specified.\r\n        if (self._preload && self._preload !== 'none') {\r\n          self.load();\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Load the audio file.\r\n       * @return {Howler}\r\n       */\r\n      load: function() {\r\n        var self = this;\r\n        var url = null;\r\n  \r\n        // If no audio is available, quit immediately.\r\n        if (Howler.noAudio) {\r\n          self._emit('loaderror', null, 'No audio support.');\r\n          return;\r\n        }\r\n  \r\n        // Make sure our source is in an array.\r\n        if (typeof self._src === 'string') {\r\n          self._src = [self._src];\r\n        }\r\n  \r\n        // Loop through the sources and pick the first one that is compatible.\r\n        for (var i=0; i<self._src.length; i++) {\r\n          var ext, str;\r\n  \r\n          if (self._format && self._format[i]) {\r\n            // If an extension was specified, use that instead.\r\n            ext = self._format[i];\r\n          } else {\r\n            // Make sure the source is a string.\r\n            str = self._src[i];\r\n            if (typeof str !== 'string') {\r\n              self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');\r\n              continue;\r\n            }\r\n  \r\n            // Extract the file extension from the URL or base64 data URI.\r\n            ext = /^data:audio\\/([^;,]+);/i.exec(str);\r\n            if (!ext) {\r\n              ext = /\\.([^.]+)$/.exec(str.split('?', 1)[0]);\r\n            }\r\n  \r\n            if (ext) {\r\n              ext = ext[1].toLowerCase();\r\n            }\r\n          }\r\n  \r\n          // Log a warning if no extension was found.\r\n          if (!ext) {\r\n            console.warn('No file extension was found. Consider using the \"format\" property or specify an extension.');\r\n          }\r\n  \r\n          // Check if this extension is available.\r\n          if (ext && Howler.codecs(ext)) {\r\n            url = self._src[i];\r\n            break;\r\n          }\r\n        }\r\n  \r\n        if (!url) {\r\n          self._emit('loaderror', null, 'No codec support for selected audio sources.');\r\n          return;\r\n        }\r\n  \r\n        self._src = url;\r\n        self._state = 'loading';\r\n  \r\n        // If the hosting page is HTTPS and the source isn't,\r\n        // drop down to HTML5 Audio to avoid Mixed Content errors.\r\n        if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {\r\n          self._html5 = true;\r\n          self._webAudio = false;\r\n        }\r\n  \r\n        // Create a new sound object and add it to the pool.\r\n        new Sound(self);\r\n  \r\n        // Load and decode the audio data for playback.\r\n        if (self._webAudio) {\r\n          loadBuffer(self);\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Play a sound or resume previous playback.\r\n       * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.\r\n       * @param  {Boolean} internal Internal Use: true prevents event firing.\r\n       * @return {Number}          Sound ID.\r\n       */\r\n      play: function(sprite, internal) {\r\n        var self = this;\r\n        var id = null;\r\n  \r\n        // Determine if a sprite, sound id or nothing was passed\r\n        if (typeof sprite === 'number') {\r\n          id = sprite;\r\n          sprite = null;\r\n        } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {\r\n          // If the passed sprite doesn't exist, do nothing.\r\n          return null;\r\n        } else if (typeof sprite === 'undefined') {\r\n          // Use the default sound sprite (plays the full audio length).\r\n          sprite = '__default';\r\n  \r\n          // Check if there is a single paused sound that isn't ended.\r\n          // If there is, play that sound. If not, continue as usual.\r\n          if (!self._playLock) {\r\n            var num = 0;\r\n            for (var i=0; i<self._sounds.length; i++) {\r\n              if (self._sounds[i]._paused && !self._sounds[i]._ended) {\r\n                num++;\r\n                id = self._sounds[i]._id;\r\n              }\r\n            }\r\n  \r\n            if (num === 1) {\r\n              sprite = null;\r\n            } else {\r\n              id = null;\r\n            }\r\n          }\r\n        }\r\n  \r\n        // Get the selected node, or get one from the pool.\r\n        var sound = id ? self._soundById(id) : self._inactiveSound();\r\n  \r\n        // If the sound doesn't exist, do nothing.\r\n        if (!sound) {\r\n          return null;\r\n        }\r\n  \r\n        // Select the sprite definition.\r\n        if (id && !sprite) {\r\n          sprite = sound._sprite || '__default';\r\n        }\r\n  \r\n        // If the sound hasn't loaded, we must wait to get the audio's duration.\r\n        // We also need to wait to make sure we don't run into race conditions with\r\n        // the order of function calls.\r\n        if (self._state !== 'loaded') {\r\n          // Set the sprite value on this sound.\r\n          sound._sprite = sprite;\r\n  \r\n          // Mark this sound as not ended in case another sound is played before this one loads.\r\n          sound._ended = false;\r\n  \r\n          // Add the sound to the queue to be played on load.\r\n          var soundId = sound._id;\r\n          self._queue.push({\r\n            event: 'play',\r\n            action: function() {\r\n              self.play(soundId);\r\n            }\r\n          });\r\n  \r\n          return soundId;\r\n        }\r\n  \r\n        // Don't play the sound if an id was passed and it is already playing.\r\n        if (id && !sound._paused) {\r\n          // Trigger the play event, in order to keep iterating through queue.\r\n          if (!internal) {\r\n            self._loadQueue('play');\r\n          }\r\n  \r\n          return sound._id;\r\n        }\r\n  \r\n        // Make sure the AudioContext isn't suspended, and resume it if it is.\r\n        if (self._webAudio) {\r\n          Howler._autoResume();\r\n        }\r\n  \r\n        // Determine how long to play for and where to start playing.\r\n        var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);\r\n        var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);\r\n        var timeout = (duration * 1000) / Math.abs(sound._rate);\r\n        var start = self._sprite[sprite][0] / 1000;\r\n        var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;\r\n        sound._sprite = sprite;\r\n  \r\n        // Mark the sound as ended instantly so that this async playback\r\n        // doesn't get grabbed by another call to play while this one waits to start.\r\n        sound._ended = false;\r\n  \r\n        // Update the parameters of the sound.\r\n        var setParams = function() {\r\n          sound._paused = false;\r\n          sound._seek = seek;\r\n          sound._start = start;\r\n          sound._stop = stop;\r\n          sound._loop = !!(sound._loop || self._sprite[sprite][2]);\r\n        };\r\n  \r\n        // End the sound instantly if seek is at the end.\r\n        if (seek >= stop) {\r\n          self._ended(sound);\r\n          return;\r\n        }\r\n  \r\n        // Begin the actual playback.\r\n        var node = sound._node;\r\n        if (self._webAudio) {\r\n          // Fire this when the sound is ready to play to begin Web Audio playback.\r\n          var playWebAudio = function() {\r\n            self._playLock = false;\r\n            setParams();\r\n            self._refreshBuffer(sound);\r\n  \r\n            // Setup the playback params.\r\n            var vol = (sound._muted || self._muted) ? 0 : sound._volume;\r\n            node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\r\n            sound._playStart = Howler.ctx.currentTime;\r\n  \r\n            // Play the sound using the supported method.\r\n            if (typeof node.bufferSource.start === 'undefined') {\r\n              sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);\r\n            } else {\r\n              sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);\r\n            }\r\n  \r\n            // Start a new timer if none is present.\r\n            if (timeout !== Infinity) {\r\n              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\r\n            }\r\n  \r\n            if (!internal) {\r\n              setTimeout(function() {\r\n                self._emit('play', sound._id);\r\n                self._loadQueue();\r\n              }, 0);\r\n            }\r\n          };\r\n  \r\n          if (Howler.state === 'running' && Howler.ctx.state !== 'interrupted') {\r\n            playWebAudio();\r\n          } else {\r\n            self._playLock = true;\r\n  \r\n            // Wait for the audio context to resume before playing.\r\n            self.once('resume', playWebAudio);\r\n  \r\n            // Cancel the end timer.\r\n            self._clearTimer(sound._id);\r\n          }\r\n        } else {\r\n          // Fire this when the sound is ready to play to begin HTML5 Audio playback.\r\n          var playHtml5 = function() {\r\n            node.currentTime = seek;\r\n            node.muted = sound._muted || self._muted || Howler._muted || node.muted;\r\n            node.volume = sound._volume * Howler.volume();\r\n            node.playbackRate = sound._rate;\r\n  \r\n            // Some browsers will throw an error if this is called without user interaction.\r\n            try {\r\n              var play = node.play();\r\n  \r\n              // Support older browsers that don't support promises, and thus don't have this issue.\r\n              if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {\r\n                // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().\r\n                self._playLock = true;\r\n  \r\n                // Set param values immediately.\r\n                setParams();\r\n  \r\n                // Releases the lock and executes queued actions.\r\n                play\r\n                  .then(function() {\r\n                    self._playLock = false;\r\n                    node._unlocked = true;\r\n                    if (!internal) {\r\n                      self._emit('play', sound._id);\r\n                    } else {\r\n                      self._loadQueue();\r\n                    }\r\n                  })\r\n                  .catch(function() {\r\n                    self._playLock = false;\r\n                    self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +\r\n                      'on mobile devices and Chrome where playback was not within a user interaction.');\r\n  \r\n                    // Reset the ended and paused values.\r\n                    sound._ended = true;\r\n                    sound._paused = true;\r\n                  });\r\n              } else if (!internal) {\r\n                self._playLock = false;\r\n                setParams();\r\n                self._emit('play', sound._id);\r\n              }\r\n  \r\n              // Setting rate before playing won't work in IE, so we set it again here.\r\n              node.playbackRate = sound._rate;\r\n  \r\n              // If the node is still paused, then we can assume there was a playback issue.\r\n              if (node.paused) {\r\n                self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +\r\n                  'on mobile devices and Chrome where playback was not within a user interaction.');\r\n                return;\r\n              }\r\n  \r\n              // Setup the end timer on sprites or listen for the ended event.\r\n              if (sprite !== '__default' || sound._loop) {\r\n                self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\r\n              } else {\r\n                self._endTimers[sound._id] = function() {\r\n                  // Fire ended on this audio node.\r\n                  self._ended(sound);\r\n  \r\n                  // Clear this listener.\r\n                  node.removeEventListener('ended', self._endTimers[sound._id], false);\r\n                };\r\n                node.addEventListener('ended', self._endTimers[sound._id], false);\r\n              }\r\n            } catch (err) {\r\n              self._emit('playerror', sound._id, err);\r\n            }\r\n          };\r\n  \r\n          // If this is streaming audio, make sure the src is set and load again.\r\n          if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {\r\n            node.src = self._src;\r\n            node.load();\r\n          }\r\n  \r\n          // Play immediately if ready, or wait for the 'canplaythrough'e vent.\r\n          var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);\r\n          if (node.readyState >= 3 || loadedNoReadyState) {\r\n            playHtml5();\r\n          } else {\r\n            self._playLock = true;\r\n            self._state = 'loading';\r\n  \r\n            var listener = function() {\r\n              self._state = 'loaded';\r\n              \r\n              // Begin playback.\r\n              playHtml5();\r\n  \r\n              // Clear this listener.\r\n              node.removeEventListener(Howler._canPlayEvent, listener, false);\r\n            };\r\n            node.addEventListener(Howler._canPlayEvent, listener, false);\r\n  \r\n            // Cancel the end timer.\r\n            self._clearTimer(sound._id);\r\n          }\r\n        }\r\n  \r\n        return sound._id;\r\n      },\r\n  \r\n      /**\r\n       * Pause playback and save current position.\r\n       * @param  {Number} id The sound ID (empty to pause all in group).\r\n       * @return {Howl}\r\n       */\r\n      pause: function(id) {\r\n        var self = this;\r\n  \r\n        // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.\r\n        if (self._state !== 'loaded' || self._playLock) {\r\n          self._queue.push({\r\n            event: 'pause',\r\n            action: function() {\r\n              self.pause(id);\r\n            }\r\n          });\r\n  \r\n          return self;\r\n        }\r\n  \r\n        // If no id is passed, get all ID's to be paused.\r\n        var ids = self._getSoundIds(id);\r\n  \r\n        for (var i=0; i<ids.length; i++) {\r\n          // Clear the end timer.\r\n          self._clearTimer(ids[i]);\r\n  \r\n          // Get the sound.\r\n          var sound = self._soundById(ids[i]);\r\n  \r\n          if (sound && !sound._paused) {\r\n            // Reset the seek position.\r\n            sound._seek = self.seek(ids[i]);\r\n            sound._rateSeek = 0;\r\n            sound._paused = true;\r\n  \r\n            // Stop currently running fades.\r\n            self._stopFade(ids[i]);\r\n  \r\n            if (sound._node) {\r\n              if (self._webAudio) {\r\n                // Make sure the sound has been created.\r\n                if (!sound._node.bufferSource) {\r\n                  continue;\r\n                }\r\n  \r\n                if (typeof sound._node.bufferSource.stop === 'undefined') {\r\n                  sound._node.bufferSource.noteOff(0);\r\n                } else {\r\n                  sound._node.bufferSource.stop(0);\r\n                }\r\n  \r\n                // Clean up the buffer source.\r\n                self._cleanBuffer(sound._node);\r\n              } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\r\n                sound._node.pause();\r\n              }\r\n            }\r\n          }\r\n  \r\n          // Fire the pause event, unless `true` is passed as the 2nd argument.\r\n          if (!arguments[1]) {\r\n            self._emit('pause', sound ? sound._id : null);\r\n          }\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Stop playback and reset to start.\r\n       * @param  {Number} id The sound ID (empty to stop all in group).\r\n       * @param  {Boolean} internal Internal Use: true prevents event firing.\r\n       * @return {Howl}\r\n       */\r\n      stop: function(id, internal) {\r\n        var self = this;\r\n  \r\n        // If the sound hasn't loaded, add it to the load queue to stop when capable.\r\n        if (self._state !== 'loaded' || self._playLock) {\r\n          self._queue.push({\r\n            event: 'stop',\r\n            action: function() {\r\n              self.stop(id);\r\n            }\r\n          });\r\n  \r\n          return self;\r\n        }\r\n  \r\n        // If no id is passed, get all ID's to be stopped.\r\n        var ids = self._getSoundIds(id);\r\n  \r\n        for (var i=0; i<ids.length; i++) {\r\n          // Clear the end timer.\r\n          self._clearTimer(ids[i]);\r\n  \r\n          // Get the sound.\r\n          var sound = self._soundById(ids[i]);\r\n  \r\n          if (sound) {\r\n            // Reset the seek position.\r\n            sound._seek = sound._start || 0;\r\n            sound._rateSeek = 0;\r\n            sound._paused = true;\r\n            sound._ended = true;\r\n  \r\n            // Stop currently running fades.\r\n            self._stopFade(ids[i]);\r\n  \r\n            if (sound._node) {\r\n              if (self._webAudio) {\r\n                // Make sure the sound's AudioBufferSourceNode has been created.\r\n                if (sound._node.bufferSource) {\r\n                  if (typeof sound._node.bufferSource.stop === 'undefined') {\r\n                    sound._node.bufferSource.noteOff(0);\r\n                  } else {\r\n                    sound._node.bufferSource.stop(0);\r\n                  }\r\n  \r\n                  // Clean up the buffer source.\r\n                  self._cleanBuffer(sound._node);\r\n                }\r\n              } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\r\n                sound._node.currentTime = sound._start || 0;\r\n                sound._node.pause();\r\n  \r\n                // If this is a live stream, stop download once the audio is stopped.\r\n                if (sound._node.duration === Infinity) {\r\n                  self._clearSound(sound._node);\r\n                }\r\n              }\r\n            }\r\n  \r\n            if (!internal) {\r\n              self._emit('stop', sound._id);\r\n            }\r\n          }\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Mute/unmute a single sound or all sounds in this Howl group.\r\n       * @param  {Boolean} muted Set to true to mute and false to unmute.\r\n       * @param  {Number} id    The sound ID to update (omit to mute/unmute all).\r\n       * @return {Howl}\r\n       */\r\n      mute: function(muted, id) {\r\n        var self = this;\r\n  \r\n        // If the sound hasn't loaded, add it to the load queue to mute when capable.\r\n        if (self._state !== 'loaded'|| self._playLock) {\r\n          self._queue.push({\r\n            event: 'mute',\r\n            action: function() {\r\n              self.mute(muted, id);\r\n            }\r\n          });\r\n  \r\n          return self;\r\n        }\r\n  \r\n        // If applying mute/unmute to all sounds, update the group's value.\r\n        if (typeof id === 'undefined') {\r\n          if (typeof muted === 'boolean') {\r\n            self._muted = muted;\r\n          } else {\r\n            return self._muted;\r\n          }\r\n        }\r\n  \r\n        // If no id is passed, get all ID's to be muted.\r\n        var ids = self._getSoundIds(id);\r\n  \r\n        for (var i=0; i<ids.length; i++) {\r\n          // Get the sound.\r\n          var sound = self._soundById(ids[i]);\r\n  \r\n          if (sound) {\r\n            sound._muted = muted;\r\n  \r\n            // Cancel active fade and set the volume to the end value.\r\n            if (sound._interval) {\r\n              self._stopFade(sound._id);\r\n            }\r\n  \r\n            if (self._webAudio && sound._node) {\r\n              sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);\r\n            } else if (sound._node) {\r\n              sound._node.muted = Howler._muted ? true : muted;\r\n            }\r\n  \r\n            self._emit('mute', sound._id);\r\n          }\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.\r\n       *   volume() -> Returns the group's volume value.\r\n       *   volume(id) -> Returns the sound id's current volume.\r\n       *   volume(vol) -> Sets the volume of all sounds in this Howl group.\r\n       *   volume(vol, id) -> Sets the volume of passed sound id.\r\n       * @return {Howl/Number} Returns self or current volume.\r\n       */\r\n      volume: function() {\r\n        var self = this;\r\n        var args = arguments;\r\n        var vol, id;\r\n  \r\n        // Determine the values based on arguments.\r\n        if (args.length === 0) {\r\n          // Return the value of the groups' volume.\r\n          return self._volume;\r\n        } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {\r\n          // First check if this is an ID, and if not, assume it is a new volume.\r\n          var ids = self._getSoundIds();\r\n          var index = ids.indexOf(args[0]);\r\n          if (index >= 0) {\r\n            id = parseInt(args[0], 10);\r\n          } else {\r\n            vol = parseFloat(args[0]);\r\n          }\r\n        } else if (args.length >= 2) {\r\n          vol = parseFloat(args[0]);\r\n          id = parseInt(args[1], 10);\r\n        }\r\n  \r\n        // Update the volume or return the current volume.\r\n        var sound;\r\n        if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\r\n          // If the sound hasn't loaded, add it to the load queue to change volume when capable.\r\n          if (self._state !== 'loaded'|| self._playLock) {\r\n            self._queue.push({\r\n              event: 'volume',\r\n              action: function() {\r\n                self.volume.apply(self, args);\r\n              }\r\n            });\r\n  \r\n            return self;\r\n          }\r\n  \r\n          // Set the group volume.\r\n          if (typeof id === 'undefined') {\r\n            self._volume = vol;\r\n          }\r\n  \r\n          // Update one or all volumes.\r\n          id = self._getSoundIds(id);\r\n          for (var i=0; i<id.length; i++) {\r\n            // Get the sound.\r\n            sound = self._soundById(id[i]);\r\n  \r\n            if (sound) {\r\n              sound._volume = vol;\r\n  \r\n              // Stop currently running fades.\r\n              if (!args[2]) {\r\n                self._stopFade(id[i]);\r\n              }\r\n  \r\n              if (self._webAudio && sound._node && !sound._muted) {\r\n                sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\r\n              } else if (sound._node && !sound._muted) {\r\n                sound._node.volume = vol * Howler.volume();\r\n              }\r\n  \r\n              self._emit('volume', sound._id);\r\n            }\r\n          }\r\n        } else {\r\n          sound = id ? self._soundById(id) : self._sounds[0];\r\n          return sound ? sound._volume : 0;\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).\r\n       * @param  {Number} from The value to fade from (0.0 to 1.0).\r\n       * @param  {Number} to   The volume to fade to (0.0 to 1.0).\r\n       * @param  {Number} len  Time in milliseconds to fade.\r\n       * @param  {Number} id   The sound id (omit to fade all sounds).\r\n       * @return {Howl}\r\n       */\r\n      fade: function(from, to, len, id) {\r\n        var self = this;\r\n  \r\n        // If the sound hasn't loaded, add it to the load queue to fade when capable.\r\n        if (self._state !== 'loaded' || self._playLock) {\r\n          self._queue.push({\r\n            event: 'fade',\r\n            action: function() {\r\n              self.fade(from, to, len, id);\r\n            }\r\n          });\r\n  \r\n          return self;\r\n        }\r\n  \r\n        // Make sure the to/from/len values are numbers.\r\n        from = Math.min(Math.max(0, parseFloat(from)), 1);\r\n        to = Math.min(Math.max(0, parseFloat(to)), 1);\r\n        len = parseFloat(len);\r\n  \r\n        // Set the volume to the start position.\r\n        self.volume(from, id);\r\n  \r\n        // Fade the volume of one or all sounds.\r\n        var ids = self._getSoundIds(id);\r\n        for (var i=0; i<ids.length; i++) {\r\n          // Get the sound.\r\n          var sound = self._soundById(ids[i]);\r\n  \r\n          // Create a linear fade or fall back to timeouts with HTML5 Audio.\r\n          if (sound) {\r\n            // Stop the previous fade if no sprite is being used (otherwise, volume handles this).\r\n            if (!id) {\r\n              self._stopFade(ids[i]);\r\n            }\r\n  \r\n            // If we are using Web Audio, let the native methods do the actual fade.\r\n            if (self._webAudio && !sound._muted) {\r\n              var currentTime = Howler.ctx.currentTime;\r\n              var end = currentTime + (len / 1000);\r\n              sound._volume = from;\r\n              sound._node.gain.setValueAtTime(from, currentTime);\r\n              sound._node.gain.linearRampToValueAtTime(to, end);\r\n            }\r\n  \r\n            self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');\r\n          }\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Starts the internal interval to fade a sound.\r\n       * @param  {Object} sound Reference to sound to fade.\r\n       * @param  {Number} from The value to fade from (0.0 to 1.0).\r\n       * @param  {Number} to   The volume to fade to (0.0 to 1.0).\r\n       * @param  {Number} len  Time in milliseconds to fade.\r\n       * @param  {Number} id   The sound id to fade.\r\n       * @param  {Boolean} isGroup   If true, set the volume on the group.\r\n       */\r\n      _startFadeInterval: function(sound, from, to, len, id, isGroup) {\r\n        var self = this;\r\n        var vol = from;\r\n        var diff = to - from;\r\n        var steps = Math.abs(diff / 0.01);\r\n        var stepLen = Math.max(4, (steps > 0) ? len / steps : len);\r\n        var lastTick = Date.now();\r\n  \r\n        // Store the value being faded to.\r\n        sound._fadeTo = to;\r\n  \r\n        // Update the volume value on each interval tick.\r\n        sound._interval = setInterval(function() {\r\n          // Update the volume based on the time since the last tick.\r\n          var tick = (Date.now() - lastTick) / len;\r\n          lastTick = Date.now();\r\n          vol += diff * tick;\r\n  \r\n          // Round to within 2 decimal points.\r\n          vol = Math.round(vol * 100) / 100;\r\n  \r\n          // Make sure the volume is in the right bounds.\r\n          if (diff < 0) {\r\n            vol = Math.max(to, vol);\r\n          } else {\r\n            vol = Math.min(to, vol);\r\n          }\r\n  \r\n          // Change the volume.\r\n          if (self._webAudio) {\r\n            sound._volume = vol;\r\n          } else {\r\n            self.volume(vol, sound._id, true);\r\n          }\r\n  \r\n          // Set the group's volume.\r\n          if (isGroup) {\r\n            self._volume = vol;\r\n          }\r\n  \r\n          // When the fade is complete, stop it and fire event.\r\n          if ((to < from && vol <= to) || (to > from && vol >= to)) {\r\n            clearInterval(sound._interval);\r\n            sound._interval = null;\r\n            sound._fadeTo = null;\r\n            self.volume(to, sound._id);\r\n            self._emit('fade', sound._id);\r\n          }\r\n        }, stepLen);\r\n      },\r\n  \r\n      /**\r\n       * Internal method that stops the currently playing fade when\r\n       * a new fade starts, volume is changed or the sound is stopped.\r\n       * @param  {Number} id The sound id.\r\n       * @return {Howl}\r\n       */\r\n      _stopFade: function(id) {\r\n        var self = this;\r\n        var sound = self._soundById(id);\r\n  \r\n        if (sound && sound._interval) {\r\n          if (self._webAudio) {\r\n            sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);\r\n          }\r\n  \r\n          clearInterval(sound._interval);\r\n          sound._interval = null;\r\n          self.volume(sound._fadeTo, id);\r\n          sound._fadeTo = null;\r\n          self._emit('fade', id);\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.\r\n       *   loop() -> Returns the group's loop value.\r\n       *   loop(id) -> Returns the sound id's loop value.\r\n       *   loop(loop) -> Sets the loop value for all sounds in this Howl group.\r\n       *   loop(loop, id) -> Sets the loop value of passed sound id.\r\n       * @return {Howl/Boolean} Returns self or current loop value.\r\n       */\r\n      loop: function() {\r\n        var self = this;\r\n        var args = arguments;\r\n        var loop, id, sound;\r\n  \r\n        // Determine the values for loop and id.\r\n        if (args.length === 0) {\r\n          // Return the grou's loop value.\r\n          return self._loop;\r\n        } else if (args.length === 1) {\r\n          if (typeof args[0] === 'boolean') {\r\n            loop = args[0];\r\n            self._loop = loop;\r\n          } else {\r\n            // Return this sound's loop value.\r\n            sound = self._soundById(parseInt(args[0], 10));\r\n            return sound ? sound._loop : false;\r\n          }\r\n        } else if (args.length === 2) {\r\n          loop = args[0];\r\n          id = parseInt(args[1], 10);\r\n        }\r\n  \r\n        // If no id is passed, get all ID's to be looped.\r\n        var ids = self._getSoundIds(id);\r\n        for (var i=0; i<ids.length; i++) {\r\n          sound = self._soundById(ids[i]);\r\n  \r\n          if (sound) {\r\n            sound._loop = loop;\r\n            if (self._webAudio && sound._node && sound._node.bufferSource) {\r\n              sound._node.bufferSource.loop = loop;\r\n              if (loop) {\r\n                sound._node.bufferSource.loopStart = sound._start || 0;\r\n                sound._node.bufferSource.loopEnd = sound._stop;\r\n  \r\n                // If playing, restart playback to ensure looping updates.\r\n                if (self.playing(ids[i])) {\r\n                  self.pause(ids[i], true);\r\n                  self.play(ids[i], true);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.\r\n       *   rate() -> Returns the first sound node's current playback rate.\r\n       *   rate(id) -> Returns the sound id's current playback rate.\r\n       *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.\r\n       *   rate(rate, id) -> Sets the playback rate of passed sound id.\r\n       * @return {Howl/Number} Returns self or the current playback rate.\r\n       */\r\n      rate: function() {\r\n        var self = this;\r\n        var args = arguments;\r\n        var rate, id;\r\n  \r\n        // Determine the values based on arguments.\r\n        if (args.length === 0) {\r\n          // We will simply return the current rate of the first node.\r\n          id = self._sounds[0]._id;\r\n        } else if (args.length === 1) {\r\n          // First check if this is an ID, and if not, assume it is a new rate value.\r\n          var ids = self._getSoundIds();\r\n          var index = ids.indexOf(args[0]);\r\n          if (index >= 0) {\r\n            id = parseInt(args[0], 10);\r\n          } else {\r\n            rate = parseFloat(args[0]);\r\n          }\r\n        } else if (args.length === 2) {\r\n          rate = parseFloat(args[0]);\r\n          id = parseInt(args[1], 10);\r\n        }\r\n  \r\n        // Update the playback rate or return the current value.\r\n        var sound;\r\n        if (typeof rate === 'number') {\r\n          // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.\r\n          if (self._state !== 'loaded' || self._playLock) {\r\n            self._queue.push({\r\n              event: 'rate',\r\n              action: function() {\r\n                self.rate.apply(self, args);\r\n              }\r\n            });\r\n  \r\n            return self;\r\n          }\r\n  \r\n          // Set the group rate.\r\n          if (typeof id === 'undefined') {\r\n            self._rate = rate;\r\n          }\r\n  \r\n          // Update one or all volumes.\r\n          id = self._getSoundIds(id);\r\n          for (var i=0; i<id.length; i++) {\r\n            // Get the sound.\r\n            sound = self._soundById(id[i]);\r\n  \r\n            if (sound) {\r\n              // Keep track of our position when the rate changed and update the playback\r\n              // start position so we can properly adjust the seek position for time elapsed.\r\n              if (self.playing(id[i])) {\r\n                sound._rateSeek = self.seek(id[i]);\r\n                sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;\r\n              }\r\n              sound._rate = rate;\r\n  \r\n              // Change the playback rate.\r\n              if (self._webAudio && sound._node && sound._node.bufferSource) {\r\n                sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);\r\n              } else if (sound._node) {\r\n                sound._node.playbackRate = rate;\r\n              }\r\n  \r\n              // Reset the timers.\r\n              var seek = self.seek(id[i]);\r\n              var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;\r\n              var timeout = (duration * 1000) / Math.abs(sound._rate);\r\n  \r\n              // Start a new end timer if sound is already playing.\r\n              if (self._endTimers[id[i]] || !sound._paused) {\r\n                self._clearTimer(id[i]);\r\n                self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);\r\n              }\r\n  \r\n              self._emit('rate', sound._id);\r\n            }\r\n          }\r\n        } else {\r\n          sound = self._soundById(id);\r\n          return sound ? sound._rate : self._rate;\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.\r\n       *   seek() -> Returns the first sound node's current seek position.\r\n       *   seek(id) -> Returns the sound id's current seek position.\r\n       *   seek(seek) -> Sets the seek position of the first sound node.\r\n       *   seek(seek, id) -> Sets the seek position of passed sound id.\r\n       * @return {Howl/Number} Returns self or the current seek position.\r\n       */\r\n      seek: function() {\r\n        var self = this;\r\n        var args = arguments;\r\n        var seek, id;\r\n  \r\n        // Determine the values based on arguments.\r\n        if (args.length === 0) {\r\n          // We will simply return the current position of the first node.\r\n          if (self._sounds.length) {\r\n            id = self._sounds[0]._id;\r\n          }\r\n        } else if (args.length === 1) {\r\n          // First check if this is an ID, and if not, assume it is a new seek position.\r\n          var ids = self._getSoundIds();\r\n          var index = ids.indexOf(args[0]);\r\n          if (index >= 0) {\r\n            id = parseInt(args[0], 10);\r\n          } else if (self._sounds.length) {\r\n            id = self._sounds[0]._id;\r\n            seek = parseFloat(args[0]);\r\n          }\r\n        } else if (args.length === 2) {\r\n          seek = parseFloat(args[0]);\r\n          id = parseInt(args[1], 10);\r\n        }\r\n  \r\n        // If there is no ID, bail out.\r\n        if (typeof id === 'undefined') {\r\n          return 0;\r\n        }\r\n  \r\n        // If the sound hasn't loaded, add it to the load queue to seek when capable.\r\n        if (typeof seek === 'number' && (self._state !== 'loaded' || self._playLock)) {\r\n          self._queue.push({\r\n            event: 'seek',\r\n            action: function() {\r\n              self.seek.apply(self, args);\r\n            }\r\n          });\r\n  \r\n          return self;\r\n        }\r\n  \r\n        // Get the sound.\r\n        var sound = self._soundById(id);\r\n  \r\n        if (sound) {\r\n          if (typeof seek === 'number' && seek >= 0) {\r\n            // Pause the sound and update position for restarting playback.\r\n            var playing = self.playing(id);\r\n            if (playing) {\r\n              self.pause(id, true);\r\n            }\r\n  \r\n            // Move the position of the track and cancel timer.\r\n            sound._seek = seek;\r\n            sound._ended = false;\r\n            self._clearTimer(id);\r\n  \r\n            // Update the seek position for HTML5 Audio.\r\n            if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {\r\n              sound._node.currentTime = seek;\r\n            }\r\n  \r\n            // Seek and emit when ready.\r\n            var seekAndEmit = function() {\r\n              // Restart the playback if the sound was playing.\r\n              if (playing) {\r\n                self.play(id, true);\r\n              }\r\n  \r\n              self._emit('seek', id);\r\n            };\r\n  \r\n            // Wait for the play lock to be unset before emitting (HTML5 Audio).\r\n            if (playing && !self._webAudio) {\r\n              var emitSeek = function() {\r\n                if (!self._playLock) {\r\n                  seekAndEmit();\r\n                } else {\r\n                  setTimeout(emitSeek, 0);\r\n                }\r\n              };\r\n              setTimeout(emitSeek, 0);\r\n            } else {\r\n              seekAndEmit();\r\n            }\r\n          } else {\r\n            if (self._webAudio) {\r\n              var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;\r\n              var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;\r\n              return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));\r\n            } else {\r\n              return sound._node.currentTime;\r\n            }\r\n          }\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.\r\n       * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.\r\n       * @return {Boolean} True if playing and false if not.\r\n       */\r\n      playing: function(id) {\r\n        var self = this;\r\n  \r\n        // Check the passed sound ID (if any).\r\n        if (typeof id === 'number') {\r\n          var sound = self._soundById(id);\r\n          return sound ? !sound._paused : false;\r\n        }\r\n  \r\n        // Otherwise, loop through all sounds and check if any are playing.\r\n        for (var i=0; i<self._sounds.length; i++) {\r\n          if (!self._sounds[i]._paused) {\r\n            return true;\r\n          }\r\n        }\r\n  \r\n        return false;\r\n      },\r\n  \r\n      /**\r\n       * Get the duration of this sound. Passing a sound id will return the sprite duration.\r\n       * @param  {Number} id The sound id to check. If none is passed, return full source duration.\r\n       * @return {Number} Audio duration in seconds.\r\n       */\r\n      duration: function(id) {\r\n        var self = this;\r\n        var duration = self._duration;\r\n  \r\n        // If we pass an ID, get the sound and return the sprite length.\r\n        var sound = self._soundById(id);\r\n        if (sound) {\r\n          duration = self._sprite[sound._sprite][1] / 1000;\r\n        }\r\n  \r\n        return duration;\r\n      },\r\n  \r\n      /**\r\n       * Returns the current loaded state of this Howl.\r\n       * @return {String} 'unloaded', 'loading', 'loaded'\r\n       */\r\n      state: function() {\r\n        return this._state;\r\n      },\r\n  \r\n      /**\r\n       * Unload and destroy the current Howl object.\r\n       * This will immediately stop all sound instances attached to this group.\r\n       */\r\n      unload: function() {\r\n        var self = this;\r\n  \r\n        // Stop playing any active sounds.\r\n        var sounds = self._sounds;\r\n        for (var i=0; i<sounds.length; i++) {\r\n          // Stop the sound if it is currently playing.\r\n          if (!sounds[i]._paused) {\r\n            self.stop(sounds[i]._id);\r\n          }\r\n  \r\n          // Remove the source or disconnect.\r\n          if (!self._webAudio) {\r\n            // Set the source to 0-second silence to stop any downloading (except in IE).\r\n            self._clearSound(sounds[i]._node);\r\n  \r\n            // Remove any event listeners.\r\n            sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);\r\n            sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);\r\n            sounds[i]._node.removeEventListener('ended', sounds[i]._endFn, false);\r\n  \r\n            // Release the Audio object back to the pool.\r\n            Howler._releaseHtml5Audio(sounds[i]._node);\r\n          }\r\n  \r\n          // Empty out all of the nodes.\r\n          delete sounds[i]._node;\r\n  \r\n          // Make sure all timers are cleared out.\r\n          self._clearTimer(sounds[i]._id);\r\n        }\r\n  \r\n        // Remove the references in the global Howler object.\r\n        var index = Howler._howls.indexOf(self);\r\n        if (index >= 0) {\r\n          Howler._howls.splice(index, 1);\r\n        }\r\n  \r\n        // Delete this sound from the cache (if no other Howl is using it).\r\n        var remCache = true;\r\n        for (i=0; i<Howler._howls.length; i++) {\r\n          if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {\r\n            remCache = false;\r\n            break;\r\n          }\r\n        }\r\n  \r\n        if (cache && remCache) {\r\n          delete cache[self._src];\r\n        }\r\n  \r\n        // Clear global errors.\r\n        Howler.noAudio = false;\r\n  \r\n        // Clear out `self`.\r\n        self._state = 'unloaded';\r\n        self._sounds = [];\r\n        self = null;\r\n  \r\n        return null;\r\n      },\r\n  \r\n      /**\r\n       * Listen to a custom event.\r\n       * @param  {String}   event Event name.\r\n       * @param  {Function} fn    Listener to call.\r\n       * @param  {Number}   id    (optional) Only listen to events for this sound.\r\n       * @param  {Number}   once  (INTERNAL) Marks event to fire only once.\r\n       * @return {Howl}\r\n       */\r\n      on: function(event, fn, id, once) {\r\n        var self = this;\r\n        var events = self['_on' + event];\r\n  \r\n        if (typeof fn === 'function') {\r\n          events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Remove a custom event. Call without parameters to remove all events.\r\n       * @param  {String}   event Event name.\r\n       * @param  {Function} fn    Listener to remove. Leave empty to remove all.\r\n       * @param  {Number}   id    (optional) Only remove events for this sound.\r\n       * @return {Howl}\r\n       */\r\n      off: function(event, fn, id) {\r\n        var self = this;\r\n        var events = self['_on' + event];\r\n        var i = 0;\r\n  \r\n        // Allow passing just an event and ID.\r\n        if (typeof fn === 'number') {\r\n          id = fn;\r\n          fn = null;\r\n        }\r\n  \r\n        if (fn || id) {\r\n          // Loop through event store and remove the passed function.\r\n          for (i=0; i<events.length; i++) {\r\n            var isId = (id === events[i].id);\r\n            if (fn === events[i].fn && isId || !fn && isId) {\r\n              events.splice(i, 1);\r\n              break;\r\n            }\r\n          }\r\n        } else if (event) {\r\n          // Clear out all events of this type.\r\n          self['_on' + event] = [];\r\n        } else {\r\n          // Clear out all events of every type.\r\n          var keys = Object.keys(self);\r\n          for (i=0; i<keys.length; i++) {\r\n            if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {\r\n              self[keys[i]] = [];\r\n            }\r\n          }\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Listen to a custom event and remove it once fired.\r\n       * @param  {String}   event Event name.\r\n       * @param  {Function} fn    Listener to call.\r\n       * @param  {Number}   id    (optional) Only listen to events for this sound.\r\n       * @return {Howl}\r\n       */\r\n      once: function(event, fn, id) {\r\n        var self = this;\r\n  \r\n        // Setup the event listener.\r\n        self.on(event, fn, id, 1);\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Emit all events of a specific type and pass the sound id.\r\n       * @param  {String} event Event name.\r\n       * @param  {Number} id    Sound ID.\r\n       * @param  {Number} msg   Message to go with event.\r\n       * @return {Howl}\r\n       */\r\n      _emit: function(event, id, msg) {\r\n        var self = this;\r\n        var events = self['_on' + event];\r\n  \r\n        // Loop through event store and fire all functions.\r\n        for (var i=events.length-1; i>=0; i--) {\r\n          // Only fire the listener if the correct ID is used.\r\n          if (!events[i].id || events[i].id === id || event === 'load') {\r\n            setTimeout(function(fn) {\r\n              fn.call(this, id, msg);\r\n            }.bind(self, events[i].fn), 0);\r\n  \r\n            // If this event was setup with `once`, remove it.\r\n            if (events[i].once) {\r\n              self.off(event, events[i].fn, events[i].id);\r\n            }\r\n          }\r\n        }\r\n  \r\n        // Pass the event type into load queue so that it can continue stepping.\r\n        self._loadQueue(event);\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Queue of actions initiated before the sound has loaded.\r\n       * These will be called in sequence, with the next only firing\r\n       * after the previous has finished executing (even if async like play).\r\n       * @return {Howl}\r\n       */\r\n      _loadQueue: function(event) {\r\n        var self = this;\r\n  \r\n        if (self._queue.length > 0) {\r\n          var task = self._queue[0];\r\n  \r\n          // Remove this task if a matching event was passed.\r\n          if (task.event === event) {\r\n            self._queue.shift();\r\n            self._loadQueue();\r\n          }\r\n  \r\n          // Run the task if no event type is passed.\r\n          if (!event) {\r\n            task.action();\r\n          }\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Fired when playback ends at the end of the duration.\r\n       * @param  {Sound} sound The sound object to work with.\r\n       * @return {Howl}\r\n       */\r\n      _ended: function(sound) {\r\n        var self = this;\r\n        var sprite = sound._sprite;\r\n  \r\n        // If we are using IE and there was network latency we may be clipping\r\n        // audio before it completes playing. Lets check the node to make sure it\r\n        // believes it has completed, before ending the playback.\r\n        if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {\r\n          setTimeout(self._ended.bind(self, sound), 100);\r\n          return self;\r\n        }\r\n  \r\n        // Should this sound loop?\r\n        var loop = !!(sound._loop || self._sprite[sprite][2]);\r\n  \r\n        // Fire the ended event.\r\n        self._emit('end', sound._id);\r\n  \r\n        // Restart the playback for HTML5 Audio loop.\r\n        if (!self._webAudio && loop) {\r\n          self.stop(sound._id, true).play(sound._id);\r\n        }\r\n  \r\n        // Restart this timer if on a Web Audio loop.\r\n        if (self._webAudio && loop) {\r\n          self._emit('play', sound._id);\r\n          sound._seek = sound._start || 0;\r\n          sound._rateSeek = 0;\r\n          sound._playStart = Howler.ctx.currentTime;\r\n  \r\n          var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);\r\n          self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\r\n        }\r\n  \r\n        // Mark the node as paused.\r\n        if (self._webAudio && !loop) {\r\n          sound._paused = true;\r\n          sound._ended = true;\r\n          sound._seek = sound._start || 0;\r\n          sound._rateSeek = 0;\r\n          self._clearTimer(sound._id);\r\n  \r\n          // Clean up the buffer source.\r\n          self._cleanBuffer(sound._node);\r\n  \r\n          // Attempt to auto-suspend AudioContext if no sounds are still playing.\r\n          Howler._autoSuspend();\r\n        }\r\n  \r\n        // When using a sprite, end the track.\r\n        if (!self._webAudio && !loop) {\r\n          self.stop(sound._id, true);\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Clear the end timer for a sound playback.\r\n       * @param  {Number} id The sound ID.\r\n       * @return {Howl}\r\n       */\r\n      _clearTimer: function(id) {\r\n        var self = this;\r\n  \r\n        if (self._endTimers[id]) {\r\n          // Clear the timeout or remove the ended listener.\r\n          if (typeof self._endTimers[id] !== 'function') {\r\n            clearTimeout(self._endTimers[id]);\r\n          } else {\r\n            var sound = self._soundById(id);\r\n            if (sound && sound._node) {\r\n              sound._node.removeEventListener('ended', self._endTimers[id], false);\r\n            }\r\n          }\r\n  \r\n          delete self._endTimers[id];\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Return the sound identified by this ID, or return null.\r\n       * @param  {Number} id Sound ID\r\n       * @return {Object}    Sound object or null.\r\n       */\r\n      _soundById: function(id) {\r\n        var self = this;\r\n  \r\n        // Loop through all sounds and find the one with this ID.\r\n        for (var i=0; i<self._sounds.length; i++) {\r\n          if (id === self._sounds[i]._id) {\r\n            return self._sounds[i];\r\n          }\r\n        }\r\n  \r\n        return null;\r\n      },\r\n  \r\n      /**\r\n       * Return an inactive sound from the pool or create a new one.\r\n       * @return {Sound} Sound playback object.\r\n       */\r\n      _inactiveSound: function() {\r\n        var self = this;\r\n  \r\n        self._drain();\r\n  \r\n        // Find the first inactive node to recycle.\r\n        for (var i=0; i<self._sounds.length; i++) {\r\n          if (self._sounds[i]._ended) {\r\n            return self._sounds[i].reset();\r\n          }\r\n        }\r\n  \r\n        // If no inactive node was found, create a new one.\r\n        return new Sound(self);\r\n      },\r\n  \r\n      /**\r\n       * Drain excess inactive sounds from the pool.\r\n       */\r\n      _drain: function() {\r\n        var self = this;\r\n        var limit = self._pool;\r\n        var cnt = 0;\r\n        var i = 0;\r\n  \r\n        // If there are less sounds than the max pool size, we are done.\r\n        if (self._sounds.length < limit) {\r\n          return;\r\n        }\r\n  \r\n        // Count the number of inactive sounds.\r\n        for (i=0; i<self._sounds.length; i++) {\r\n          if (self._sounds[i]._ended) {\r\n            cnt++;\r\n          }\r\n        }\r\n  \r\n        // Remove excess inactive sounds, going in reverse order.\r\n        for (i=self._sounds.length - 1; i>=0; i--) {\r\n          if (cnt <= limit) {\r\n            return;\r\n          }\r\n  \r\n          if (self._sounds[i]._ended) {\r\n            // Disconnect the audio source when using Web Audio.\r\n            if (self._webAudio && self._sounds[i]._node) {\r\n              self._sounds[i]._node.disconnect(0);\r\n            }\r\n  \r\n            // Remove sounds until we have the pool size.\r\n            self._sounds.splice(i, 1);\r\n            cnt--;\r\n          }\r\n        }\r\n      },\r\n  \r\n      /**\r\n       * Get all ID's from the sounds pool.\r\n       * @param  {Number} id Only return one ID if one is passed.\r\n       * @return {Array}    Array of IDs.\r\n       */\r\n      _getSoundIds: function(id) {\r\n        var self = this;\r\n  \r\n        if (typeof id === 'undefined') {\r\n          var ids = [];\r\n          for (var i=0; i<self._sounds.length; i++) {\r\n            ids.push(self._sounds[i]._id);\r\n          }\r\n  \r\n          return ids;\r\n        } else {\r\n          return [id];\r\n        }\r\n      },\r\n  \r\n      /**\r\n       * Load the sound back into the buffer source.\r\n       * @param  {Sound} sound The sound object to work with.\r\n       * @return {Howl}\r\n       */\r\n      _refreshBuffer: function(sound) {\r\n        var self = this;\r\n  \r\n        // Setup the buffer source for playback.\r\n        sound._node.bufferSource = Howler.ctx.createBufferSource();\r\n        sound._node.bufferSource.buffer = cache[self._src];\r\n  \r\n        // Connect to the correct node.\r\n        if (sound._panner) {\r\n          sound._node.bufferSource.connect(sound._panner);\r\n        } else {\r\n          sound._node.bufferSource.connect(sound._node);\r\n        }\r\n  \r\n        // Setup looping and playback rate.\r\n        sound._node.bufferSource.loop = sound._loop;\r\n        if (sound._loop) {\r\n          sound._node.bufferSource.loopStart = sound._start || 0;\r\n          sound._node.bufferSource.loopEnd = sound._stop || 0;\r\n        }\r\n        sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Prevent memory leaks by cleaning up the buffer source after playback.\r\n       * @param  {Object} node Sound's audio node containing the buffer source.\r\n       * @return {Howl}\r\n       */\r\n      _cleanBuffer: function(node) {\r\n        var self = this;\r\n        var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;\r\n  \r\n        if (Howler._scratchBuffer && node.bufferSource) {\r\n          node.bufferSource.onended = null;\r\n          node.bufferSource.disconnect(0);\r\n          if (isIOS) {\r\n            try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}\r\n          }\r\n        }\r\n        node.bufferSource = null;\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Set the source to a 0-second silence to stop any downloading (except in IE).\r\n       * @param  {Object} node Audio node to clear.\r\n       */\r\n      _clearSound: function(node) {\r\n        var checkIE = /MSIE |Trident\\//.test(Howler._navigator && Howler._navigator.userAgent);\r\n        if (!checkIE) {\r\n          node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';\r\n        }\r\n      }\r\n    };\r\n  \r\n    /** Single Sound Methods **/\r\n    /***************************************************************************/\r\n  \r\n    /**\r\n     * Setup the sound object, which each node attached to a Howl group is contained in.\r\n     * @param {Object} howl The Howl parent group.\r\n     */\r\n    var Sound = function(howl) {\r\n      this._parent = howl;\r\n      this.init();\r\n    };\r\n    Sound.prototype = {\r\n      /**\r\n       * Initialize a new Sound object.\r\n       * @return {Sound}\r\n       */\r\n      init: function() {\r\n        var self = this;\r\n        var parent = self._parent;\r\n  \r\n        // Setup the default parameters.\r\n        self._muted = parent._muted;\r\n        self._loop = parent._loop;\r\n        self._volume = parent._volume;\r\n        self._rate = parent._rate;\r\n        self._seek = 0;\r\n        self._paused = true;\r\n        self._ended = true;\r\n        self._sprite = '__default';\r\n  \r\n        // Generate a unique ID for this sound.\r\n        self._id = ++Howler._counter;\r\n  \r\n        // Add itself to the parent's pool.\r\n        parent._sounds.push(self);\r\n  \r\n        // Create the new node.\r\n        self.create();\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Create and setup a new sound object, whether HTML5 Audio or Web Audio.\r\n       * @return {Sound}\r\n       */\r\n      create: function() {\r\n        var self = this;\r\n        var parent = self._parent;\r\n        var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;\r\n  \r\n        if (parent._webAudio) {\r\n          // Create the gain node for controlling volume (the source will connect to this).\r\n          self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\r\n          self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);\r\n          self._node.paused = true;\r\n          self._node.connect(Howler.masterGain);\r\n        } else if (!Howler.noAudio) {\r\n          // Get an unlocked Audio object from the pool.\r\n          self._node = Howler._obtainHtml5Audio();\r\n  \r\n          // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).\r\n          self._errorFn = self._errorListener.bind(self);\r\n          self._node.addEventListener('error', self._errorFn, false);\r\n  \r\n          // Listen for 'canplaythrough' event to let us know the sound is ready.\r\n          self._loadFn = self._loadListener.bind(self);\r\n          self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);\r\n  \r\n          // Listen for the 'ended' event on the sound to account for edge-case where\r\n          // a finite sound has a duration of Infinity.\r\n          self._endFn = self._endListener.bind(self);\r\n          self._node.addEventListener('ended', self._endFn, false);\r\n  \r\n          // Setup the new audio node.\r\n          self._node.src = parent._src;\r\n          self._node.preload = parent._preload === true ? 'auto' : parent._preload;\r\n          self._node.volume = volume * Howler.volume();\r\n  \r\n          // Begin loading the source.\r\n          self._node.load();\r\n        }\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * Reset the parameters of this sound to the original state (for recycle).\r\n       * @return {Sound}\r\n       */\r\n      reset: function() {\r\n        var self = this;\r\n        var parent = self._parent;\r\n  \r\n        // Reset all of the parameters of this sound.\r\n        self._muted = parent._muted;\r\n        self._loop = parent._loop;\r\n        self._volume = parent._volume;\r\n        self._rate = parent._rate;\r\n        self._seek = 0;\r\n        self._rateSeek = 0;\r\n        self._paused = true;\r\n        self._ended = true;\r\n        self._sprite = '__default';\r\n  \r\n        // Generate a new ID so that it isn't confused with the previous sound.\r\n        self._id = ++Howler._counter;\r\n  \r\n        return self;\r\n      },\r\n  \r\n      /**\r\n       * HTML5 Audio error listener callback.\r\n       */\r\n      _errorListener: function() {\r\n        var self = this;\r\n  \r\n        // Fire an error event and pass back the code.\r\n        self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);\r\n  \r\n        // Clear the event listener.\r\n        self._node.removeEventListener('error', self._errorFn, false);\r\n      },\r\n  \r\n      /**\r\n       * HTML5 Audio canplaythrough listener callback.\r\n       */\r\n      _loadListener: function() {\r\n        var self = this;\r\n        var parent = self._parent;\r\n  \r\n        // Round up the duration to account for the lower precision in HTML5 Audio.\r\n        parent._duration = Math.ceil(self._node.duration * 10) / 10;\r\n  \r\n        // Setup a sprite if none is defined.\r\n        if (Object.keys(parent._sprite).length === 0) {\r\n          parent._sprite = {__default: [0, parent._duration * 1000]};\r\n        }\r\n  \r\n        if (parent._state !== 'loaded') {\r\n          parent._state = 'loaded';\r\n          parent._emit('load');\r\n          parent._loadQueue();\r\n        }\r\n  \r\n        // Clear the event listener.\r\n        self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);\r\n      },\r\n  \r\n      /**\r\n       * HTML5 Audio ended listener callback.\r\n       */\r\n      _endListener: function() {\r\n        var self = this;\r\n        var parent = self._parent;\r\n  \r\n        // Only handle the `ended`` event if the duration is Infinity.\r\n        if (parent._duration === Infinity) {\r\n          // Update the parent duration to match the real audio duration.\r\n          // Round up the duration to account for the lower precision in HTML5 Audio.\r\n          parent._duration = Math.ceil(self._node.duration * 10) / 10;\r\n  \r\n          // Update the sprite that corresponds to the real duration.\r\n          if (parent._sprite.__default[1] === Infinity) {\r\n            parent._sprite.__default[1] = parent._duration * 1000;\r\n          }\r\n  \r\n          // Run the regular ended method.\r\n          parent._ended(self);\r\n        }\r\n  \r\n        // Clear the event listener since the duration is now correct.\r\n        self._node.removeEventListener('ended', self._endFn, false);\r\n      }\r\n    };\r\n  \r\n    /** Helper Methods **/\r\n    /***************************************************************************/\r\n  \r\n    var cache = {};\r\n  \r\n    /**\r\n     * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).\r\n     * @param  {Howl} self\r\n     */\r\n    var loadBuffer = function(self) {\r\n      var url = self._src;\r\n  \r\n      // Check if the buffer has already been cached and use it instead.\r\n      if (cache[url]) {\r\n        // Set the duration from the cache.\r\n        self._duration = cache[url].duration;\r\n  \r\n        // Load the sound into this Howl.\r\n        loadSound(self);\r\n  \r\n        return;\r\n      }\r\n  \r\n      if (/^data:[^;]+;base64,/.test(url)) {\r\n        // Decode the base64 data URI without XHR, since some browsers don't support it.\r\n        var data = atob(url.split(',')[1]);\r\n        var dataView = new Uint8Array(data.length);\r\n        for (var i=0; i<data.length; ++i) {\r\n          dataView[i] = data.charCodeAt(i);\r\n        }\r\n  \r\n        decodeAudioData(dataView.buffer, self);\r\n      } else {\r\n        // Load the buffer from the URL.\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open(self._xhr.method, url, true);\r\n        xhr.withCredentials = self._xhr.withCredentials;\r\n        xhr.responseType = 'arraybuffer';\r\n  \r\n        // Apply any custom headers to the request.\r\n        if (self._xhr.headers) {\r\n          Object.keys(self._xhr.headers).forEach(function(key) {\r\n            xhr.setRequestHeader(key, self._xhr.headers[key]);\r\n          });\r\n        }\r\n  \r\n        xhr.onload = function() {\r\n          // Make sure we get a successful response back.\r\n          var code = (xhr.status + '')[0];\r\n          if (code !== '0' && code !== '2' && code !== '3') {\r\n            self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');\r\n            return;\r\n          }\r\n  \r\n          decodeAudioData(xhr.response, self);\r\n        };\r\n        xhr.onerror = function() {\r\n          // If there is an error, switch to HTML5 Audio.\r\n          if (self._webAudio) {\r\n            self._html5 = true;\r\n            self._webAudio = false;\r\n            self._sounds = [];\r\n            delete cache[url];\r\n            self.load();\r\n          }\r\n        };\r\n        safeXhrSend(xhr);\r\n      }\r\n    };\r\n  \r\n    /**\r\n     * Send the XHR request wrapped in a try/catch.\r\n     * @param  {Object} xhr XHR to send.\r\n     */\r\n    var safeXhrSend = function(xhr) {\r\n      try {\r\n        xhr.send();\r\n      } catch (e) {\r\n        xhr.onerror();\r\n      }\r\n    };\r\n  \r\n    /**\r\n     * Decode audio data from an array buffer.\r\n     * @param  {ArrayBuffer} arraybuffer The audio data.\r\n     * @param  {Howl}        self\r\n     */\r\n    var decodeAudioData = function(arraybuffer, self) {\r\n      // Fire a load error if something broke.\r\n      var error = function() {\r\n        self._emit('loaderror', null, 'Decoding audio data failed.');\r\n      };\r\n  \r\n      // Load the sound on success.\r\n      var success = function(buffer) {\r\n        if (buffer && self._sounds.length > 0) {\r\n          cache[self._src] = buffer;\r\n          loadSound(self, buffer);\r\n        } else {\r\n          error();\r\n        }\r\n      };\r\n  \r\n      // Decode the buffer into an audio source.\r\n      if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {\r\n        Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);\r\n      } else {\r\n        Howler.ctx.decodeAudioData(arraybuffer, success, error);\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Sound is now loaded, so finish setting everything up and fire the loaded event.\r\n     * @param  {Howl} self\r\n     * @param  {Object} buffer The decoded buffer sound source.\r\n     */\r\n    var loadSound = function(self, buffer) {\r\n      // Set the duration.\r\n      if (buffer && !self._duration) {\r\n        self._duration = buffer.duration;\r\n      }\r\n  \r\n      // Setup a sprite if none is defined.\r\n      if (Object.keys(self._sprite).length === 0) {\r\n        self._sprite = {__default: [0, self._duration * 1000]};\r\n      }\r\n  \r\n      // Fire the loaded event.\r\n      if (self._state !== 'loaded') {\r\n        self._state = 'loaded';\r\n        self._emit('load');\r\n        self._loadQueue();\r\n      }\r\n    };\r\n  \r\n    /**\r\n     * Setup the audio context when available, or switch to HTML5 Audio mode.\r\n     */\r\n    var setupAudioContext = function() {\r\n      // If we have already detected that Web Audio isn't supported, don't run this step again.\r\n      if (!Howler.usingWebAudio) {\r\n        return;\r\n      }\r\n  \r\n      // Check if we are using Web Audio and setup the AudioContext if we are.\r\n      try {\r\n        if (typeof AudioContext !== 'undefined') {\r\n          Howler.ctx = new AudioContext();\r\n        } else if (typeof webkitAudioContext !== 'undefined') {\r\n          Howler.ctx = new webkitAudioContext();\r\n        } else {\r\n          Howler.usingWebAudio = false;\r\n        }\r\n      } catch(e) {\r\n        Howler.usingWebAudio = false;\r\n      }\r\n  \r\n      // If the audio context creation still failed, set using web audio to false.\r\n      if (!Howler.ctx) {\r\n        Howler.usingWebAudio = false;\r\n      }\r\n  \r\n      // Check if a webview is being used on iOS8 or earlier (rather than the browser).\r\n      // If it is, disable Web Audio as it causes crashing.\r\n      var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));\r\n      var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\r\n      var version = appVersion ? parseInt(appVersion[1], 10) : null;\r\n      if (iOS && version && version < 9) {\r\n        var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());\r\n        if (Howler._navigator && !safari) {\r\n          Howler.usingWebAudio = false;\r\n        }\r\n      }\r\n  \r\n      // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).\r\n      if (Howler.usingWebAudio) {\r\n        Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\r\n        Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);\r\n        Howler.masterGain.connect(Howler.ctx.destination);\r\n      }\r\n  \r\n      // Re-run the setup on Howler.\r\n      Howler._setup();\r\n    };\r\n  \r\n    // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.\r\n    if (typeof define === 'function' && __webpack_require__.amdO) {\r\n      define([], function() {\r\n        return {\r\n          Howler: Howler,\r\n          Howl: Howl\r\n        };\r\n      });\r\n    }\r\n  \r\n    // Add support for CommonJS libraries such as browserify.\r\n    if (typeof exports !== 'undefined') {\r\n      exports.Howler = Howler;\r\n      exports.Howl = Howl;\r\n    }\r\n  \r\n    // Add to global in Node.js (for testing, etc).\r\n    if (typeof __webpack_require__.g !== 'undefined') {\r\n      __webpack_require__.g.HowlerGlobal = HowlerGlobal;\r\n      __webpack_require__.g.Howler = Howler;\r\n      __webpack_require__.g.Howl = Howl;\r\n      __webpack_require__.g.Sound = Sound;\r\n    } else if (typeof window !== 'undefined') {  // Define globally in case AMD is not available or unused.\r\n      window.HowlerGlobal = HowlerGlobal;\r\n      window.Howler = Howler;\r\n      window.Howl = Howl;\r\n      window.Sound = Sound;\r\n      HowlToExport = Howl;\r\n    }\r\n  })();\r\n  \r\n  \r\n  /*!\r\n   *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.\r\n   *  \r\n   *  howler.js v2.2.3\r\n   *  howlerjs.com\r\n   *\r\n   *  (c) 2013-2020, James Simpson of GoldFire Studios\r\n   *  goldfirestudios.com\r\n   *\r\n   *  MIT License\r\n   */\r\n  \r\n  (function() {\r\n  \r\n    'use strict';\r\n  \r\n    // Setup default properties.\r\n    HowlerGlobal.prototype._pos = [0, 0, 0];\r\n    HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];\r\n  \r\n    /** Global Methods **/\r\n    /***************************************************************************/\r\n  \r\n    /**\r\n     * Helper method to update the stereo panning position of all current Howls.\r\n     * Future Howls will not use this value unless explicitly set.\r\n     * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.\r\n     * @return {Howler/Number}     Self or current stereo panning value.\r\n     */\r\n    HowlerGlobal.prototype.stereo = function(pan) {\r\n      var self = this;\r\n  \r\n      // Stop right here if not using Web Audio.\r\n      if (!self.ctx || !self.ctx.listener) {\r\n        return self;\r\n      }\r\n  \r\n      // Loop through all Howls and update their stereo panning.\r\n      for (var i=self._howls.length-1; i>=0; i--) {\r\n        self._howls[i].stereo(pan);\r\n      }\r\n  \r\n      return self;\r\n    };\r\n  \r\n    /**\r\n     * Get/set the position of the listener in 3D cartesian space. Sounds using\r\n     * 3D position will be relative to the listener's position.\r\n     * @param  {Number} x The x-position of the listener.\r\n     * @param  {Number} y The y-position of the listener.\r\n     * @param  {Number} z The z-position of the listener.\r\n     * @return {Howler/Array}   Self or current listener position.\r\n     */\r\n    HowlerGlobal.prototype.pos = function(x, y, z) {\r\n      var self = this;\r\n  \r\n      // Stop right here if not using Web Audio.\r\n      if (!self.ctx || !self.ctx.listener) {\r\n        return self;\r\n      }\r\n  \r\n      // Set the defaults for optional 'y' & 'z'.\r\n      y = (typeof y !== 'number') ? self._pos[1] : y;\r\n      z = (typeof z !== 'number') ? self._pos[2] : z;\r\n  \r\n      if (typeof x === 'number') {\r\n        self._pos = [x, y, z];\r\n  \r\n        if (typeof self.ctx.listener.positionX !== 'undefined') {\r\n          self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);\r\n          self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);\r\n          self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);\r\n        } else {\r\n          self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);\r\n        }\r\n      } else {\r\n        return self._pos;\r\n      }\r\n  \r\n      return self;\r\n    };\r\n  \r\n    /**\r\n     * Get/set the direction the listener is pointing in the 3D cartesian space.\r\n     * A front and up vector must be provided. The front is the direction the\r\n     * face of the listener is pointing, and up is the direction the top of the\r\n     * listener is pointing. Thus, these values are expected to be at right angles\r\n     * from each other.\r\n     * @param  {Number} x   The x-orientation of the listener.\r\n     * @param  {Number} y   The y-orientation of the listener.\r\n     * @param  {Number} z   The z-orientation of the listener.\r\n     * @param  {Number} xUp The x-orientation of the top of the listener.\r\n     * @param  {Number} yUp The y-orientation of the top of the listener.\r\n     * @param  {Number} zUp The z-orientation of the top of the listener.\r\n     * @return {Howler/Array}     Returns self or the current orientation vectors.\r\n     */\r\n    HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {\r\n      var self = this;\r\n  \r\n      // Stop right here if not using Web Audio.\r\n      if (!self.ctx || !self.ctx.listener) {\r\n        return self;\r\n      }\r\n  \r\n      // Set the defaults for optional 'y' & 'z'.\r\n      var or = self._orientation;\r\n      y = (typeof y !== 'number') ? or[1] : y;\r\n      z = (typeof z !== 'number') ? or[2] : z;\r\n      xUp = (typeof xUp !== 'number') ? or[3] : xUp;\r\n      yUp = (typeof yUp !== 'number') ? or[4] : yUp;\r\n      zUp = (typeof zUp !== 'number') ? or[5] : zUp;\r\n  \r\n      if (typeof x === 'number') {\r\n        self._orientation = [x, y, z, xUp, yUp, zUp];\r\n  \r\n        if (typeof self.ctx.listener.forwardX !== 'undefined') {\r\n          self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);\r\n          self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);\r\n          self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);\r\n          self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);\r\n          self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);\r\n          self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);\r\n        } else {\r\n          self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);\r\n        }\r\n      } else {\r\n        return or;\r\n      }\r\n  \r\n      return self;\r\n    };\r\n  \r\n    /** Group Methods **/\r\n    /***************************************************************************/\r\n  \r\n    /**\r\n     * Add new properties to the core init.\r\n     * @param  {Function} _super Core init method.\r\n     * @return {Howl}\r\n     */\r\n    Howl.prototype.init = (function(_super) {\r\n      return function(o) {\r\n        var self = this;\r\n  \r\n        // Setup user-defined default properties.\r\n        self._orientation = o.orientation || [1, 0, 0];\r\n        self._stereo = o.stereo || null;\r\n        self._pos = o.pos || null;\r\n        self._pannerAttr = {\r\n          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,\r\n          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,\r\n          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,\r\n          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',\r\n          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,\r\n          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',\r\n          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,\r\n          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1\r\n        };\r\n  \r\n        // Setup event listeners.\r\n        self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];\r\n        self._onpos = o.onpos ? [{fn: o.onpos}] : [];\r\n        self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];\r\n  \r\n        // Complete initilization with howler.js core's init function.\r\n        return _super.call(this, o);\r\n      };\r\n    })(Howl.prototype.init);\r\n  \r\n    /**\r\n     * Get/set the stereo panning of the audio source for this sound or all in the group.\r\n     * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.\r\n     * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\r\n     * @return {Howl/Number}    Returns self or the current stereo panning value.\r\n     */\r\n    Howl.prototype.stereo = function(pan, id) {\r\n      var self = this;\r\n  \r\n      // Stop right here if not using Web Audio.\r\n      if (!self._webAudio) {\r\n        return self;\r\n      }\r\n  \r\n      // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.\r\n      if (self._state !== 'loaded') {\r\n        self._queue.push({\r\n          event: 'stereo',\r\n          action: function() {\r\n            self.stereo(pan, id);\r\n          }\r\n        });\r\n  \r\n        return self;\r\n      }\r\n  \r\n      // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.\r\n      var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';\r\n  \r\n      // Setup the group's stereo panning if no ID is passed.\r\n      if (typeof id === 'undefined') {\r\n        // Return the group's stereo panning if no parameters are passed.\r\n        if (typeof pan === 'number') {\r\n          self._stereo = pan;\r\n          self._pos = [pan, 0, 0];\r\n        } else {\r\n          return self._stereo;\r\n        }\r\n      }\r\n  \r\n      // Change the streo panning of one or all sounds in group.\r\n      var ids = self._getSoundIds(id);\r\n      for (var i=0; i<ids.length; i++) {\r\n        // Get the sound.\r\n        var sound = self._soundById(ids[i]);\r\n  \r\n        if (sound) {\r\n          if (typeof pan === 'number') {\r\n            sound._stereo = pan;\r\n            sound._pos = [pan, 0, 0];\r\n  \r\n            if (sound._node) {\r\n              // If we are falling back, make sure the panningModel is equalpower.\r\n              sound._pannerAttr.panningModel = 'equalpower';\r\n  \r\n              // Check if there is a panner setup and create a new one if not.\r\n              if (!sound._panner || !sound._panner.pan) {\r\n                setupPanner(sound, pannerType);\r\n              }\r\n  \r\n              if (pannerType === 'spatial') {\r\n                if (typeof sound._panner.positionX !== 'undefined') {\r\n                  sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);\r\n                  sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);\r\n                  sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);\r\n                } else {\r\n                  sound._panner.setPosition(pan, 0, 0);\r\n                }\r\n              } else {\r\n                sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);\r\n              }\r\n            }\r\n  \r\n            self._emit('stereo', sound._id);\r\n          } else {\r\n            return sound._stereo;\r\n          }\r\n        }\r\n      }\r\n  \r\n      return self;\r\n    };\r\n  \r\n    /**\r\n     * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.\r\n     * @param  {Number} x  The x-position of the audio source.\r\n     * @param  {Number} y  The y-position of the audio source.\r\n     * @param  {Number} z  The z-position of the audio source.\r\n     * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\r\n     * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].\r\n     */\r\n    Howl.prototype.pos = function(x, y, z, id) {\r\n      var self = this;\r\n  \r\n      // Stop right here if not using Web Audio.\r\n      if (!self._webAudio) {\r\n        return self;\r\n      }\r\n  \r\n      // If the sound hasn't loaded, add it to the load queue to change position when capable.\r\n      if (self._state !== 'loaded') {\r\n        self._queue.push({\r\n          event: 'pos',\r\n          action: function() {\r\n            self.pos(x, y, z, id);\r\n          }\r\n        });\r\n  \r\n        return self;\r\n      }\r\n  \r\n      // Set the defaults for optional 'y' & 'z'.\r\n      y = (typeof y !== 'number') ? 0 : y;\r\n      z = (typeof z !== 'number') ? -0.5 : z;\r\n  \r\n      // Setup the group's spatial position if no ID is passed.\r\n      if (typeof id === 'undefined') {\r\n        // Return the group's spatial position if no parameters are passed.\r\n        if (typeof x === 'number') {\r\n          self._pos = [x, y, z];\r\n        } else {\r\n          return self._pos;\r\n        }\r\n      }\r\n  \r\n      // Change the spatial position of one or all sounds in group.\r\n      var ids = self._getSoundIds(id);\r\n      for (var i=0; i<ids.length; i++) {\r\n        // Get the sound.\r\n        var sound = self._soundById(ids[i]);\r\n  \r\n        if (sound) {\r\n          if (typeof x === 'number') {\r\n            sound._pos = [x, y, z];\r\n  \r\n            if (sound._node) {\r\n              // Check if there is a panner setup and create a new one if not.\r\n              if (!sound._panner || sound._panner.pan) {\r\n                setupPanner(sound, 'spatial');\r\n              }\r\n  \r\n              if (typeof sound._panner.positionX !== 'undefined') {\r\n                sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);\r\n                sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);\r\n                sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);\r\n              } else {\r\n                sound._panner.setPosition(x, y, z);\r\n              }\r\n            }\r\n  \r\n            self._emit('pos', sound._id);\r\n          } else {\r\n            return sound._pos;\r\n          }\r\n        }\r\n      }\r\n  \r\n      return self;\r\n    };\r\n  \r\n    /**\r\n     * Get/set the direction the audio source is pointing in the 3D cartesian coordinate\r\n     * space. Depending on how direction the sound is, based on the `cone` attributes,\r\n     * a sound pointing away from the listener can be quiet or silent.\r\n     * @param  {Number} x  The x-orientation of the source.\r\n     * @param  {Number} y  The y-orientation of the source.\r\n     * @param  {Number} z  The z-orientation of the source.\r\n     * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\r\n     * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].\r\n     */\r\n    Howl.prototype.orientation = function(x, y, z, id) {\r\n      var self = this;\r\n  \r\n      // Stop right here if not using Web Audio.\r\n      if (!self._webAudio) {\r\n        return self;\r\n      }\r\n  \r\n      // If the sound hasn't loaded, add it to the load queue to change orientation when capable.\r\n      if (self._state !== 'loaded') {\r\n        self._queue.push({\r\n          event: 'orientation',\r\n          action: function() {\r\n            self.orientation(x, y, z, id);\r\n          }\r\n        });\r\n  \r\n        return self;\r\n      }\r\n  \r\n      // Set the defaults for optional 'y' & 'z'.\r\n      y = (typeof y !== 'number') ? self._orientation[1] : y;\r\n      z = (typeof z !== 'number') ? self._orientation[2] : z;\r\n  \r\n      // Setup the group's spatial orientation if no ID is passed.\r\n      if (typeof id === 'undefined') {\r\n        // Return the group's spatial orientation if no parameters are passed.\r\n        if (typeof x === 'number') {\r\n          self._orientation = [x, y, z];\r\n        } else {\r\n          return self._orientation;\r\n        }\r\n      }\r\n  \r\n      // Change the spatial orientation of one or all sounds in group.\r\n      var ids = self._getSoundIds(id);\r\n      for (var i=0; i<ids.length; i++) {\r\n        // Get the sound.\r\n        var sound = self._soundById(ids[i]);\r\n  \r\n        if (sound) {\r\n          if (typeof x === 'number') {\r\n            sound._orientation = [x, y, z];\r\n  \r\n            if (sound._node) {\r\n              // Check if there is a panner setup and create a new one if not.\r\n              if (!sound._panner) {\r\n                // Make sure we have a position to setup the node with.\r\n                if (!sound._pos) {\r\n                  sound._pos = self._pos || [0, 0, -0.5];\r\n                }\r\n  \r\n                setupPanner(sound, 'spatial');\r\n              }\r\n  \r\n              if (typeof sound._panner.orientationX !== 'undefined') {\r\n                sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);\r\n                sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);\r\n                sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);\r\n              } else {\r\n                sound._panner.setOrientation(x, y, z);\r\n              }\r\n            }\r\n  \r\n            self._emit('orientation', sound._id);\r\n          } else {\r\n            return sound._orientation;\r\n          }\r\n        }\r\n      }\r\n  \r\n      return self;\r\n    };\r\n  \r\n    /**\r\n     * Get/set the panner node's attributes for a sound or group of sounds.\r\n     * This method can optionall take 0, 1 or 2 arguments.\r\n     *   pannerAttr() -> Returns the group's values.\r\n     *   pannerAttr(id) -> Returns the sound id's values.\r\n     *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.\r\n     *   pannerAttr(o, id) -> Set's the values of passed sound id.\r\n     *\r\n     *   Attributes:\r\n     *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\r\n     *                      inside of which there will be no volume reduction.\r\n     *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\r\n     *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.\r\n     *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the\r\n     *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.\r\n     *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from\r\n     *                     listener. Can be `linear`, `inverse` or `exponential.\r\n     *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume\r\n     *                   will not be reduced any further.\r\n     *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.\r\n     *                   This is simply a variable of the distance model and has a different effect depending on which model\r\n     *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.\r\n     *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a\r\n     *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ]`\r\n     *                     with `inverse` and `exponential`.\r\n     *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.\r\n     *                     Can be `HRTF` or `equalpower`.\r\n     *\r\n     * @return {Howl/Object} Returns self or current panner attributes.\r\n     */\r\n    Howl.prototype.pannerAttr = function() {\r\n      var self = this;\r\n      var args = arguments;\r\n      var o, id, sound;\r\n  \r\n      // Stop right here if not using Web Audio.\r\n      if (!self._webAudio) {\r\n        return self;\r\n      }\r\n  \r\n      // Determine the values based on arguments.\r\n      if (args.length === 0) {\r\n        // Return the group's panner attribute values.\r\n        return self._pannerAttr;\r\n      } else if (args.length === 1) {\r\n        if (typeof args[0] === 'object') {\r\n          o = args[0];\r\n  \r\n          // Set the grou's panner attribute values.\r\n          if (typeof id === 'undefined') {\r\n            if (!o.pannerAttr) {\r\n              o.pannerAttr = {\r\n                coneInnerAngle: o.coneInnerAngle,\r\n                coneOuterAngle: o.coneOuterAngle,\r\n                coneOuterGain: o.coneOuterGain,\r\n                distanceModel: o.distanceModel,\r\n                maxDistance: o.maxDistance,\r\n                refDistance: o.refDistance,\r\n                rolloffFactor: o.rolloffFactor,\r\n                panningModel: o.panningModel\r\n              };\r\n            }\r\n  \r\n            self._pannerAttr = {\r\n              coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,\r\n              coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,\r\n              coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,\r\n              distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,\r\n              maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,\r\n              refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,\r\n              rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,\r\n              panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel\r\n            };\r\n          }\r\n        } else {\r\n          // Return this sound's panner attribute values.\r\n          sound = self._soundById(parseInt(args[0], 10));\r\n          return sound ? sound._pannerAttr : self._pannerAttr;\r\n        }\r\n      } else if (args.length === 2) {\r\n        o = args[0];\r\n        id = parseInt(args[1], 10);\r\n      }\r\n  \r\n      // Update the values of the specified sounds.\r\n      var ids = self._getSoundIds(id);\r\n      for (var i=0; i<ids.length; i++) {\r\n        sound = self._soundById(ids[i]);\r\n  \r\n        if (sound) {\r\n          // Merge the new values into the sound.\r\n          var pa = sound._pannerAttr;\r\n          pa = {\r\n            coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,\r\n            coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,\r\n            coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,\r\n            distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,\r\n            maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,\r\n            refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,\r\n            rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,\r\n            panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel\r\n          };\r\n  \r\n          // Update the panner values or create a new panner if none exists.\r\n          var panner = sound._panner;\r\n          if (panner) {\r\n            panner.coneInnerAngle = pa.coneInnerAngle;\r\n            panner.coneOuterAngle = pa.coneOuterAngle;\r\n            panner.coneOuterGain = pa.coneOuterGain;\r\n            panner.distanceModel = pa.distanceModel;\r\n            panner.maxDistance = pa.maxDistance;\r\n            panner.refDistance = pa.refDistance;\r\n            panner.rolloffFactor = pa.rolloffFactor;\r\n            panner.panningModel = pa.panningModel;\r\n          } else {\r\n            // Make sure we have a position to setup the node with.\r\n            if (!sound._pos) {\r\n              sound._pos = self._pos || [0, 0, -0.5];\r\n            }\r\n  \r\n            // Create a new panner node.\r\n            setupPanner(sound, 'spatial');\r\n          }\r\n        }\r\n      }\r\n  \r\n      return self;\r\n    };\r\n  \r\n    /** Single Sound Methods **/\r\n    /***************************************************************************/\r\n  \r\n    /**\r\n     * Add new properties to the core Sound init.\r\n     * @param  {Function} _super Core Sound init method.\r\n     * @return {Sound}\r\n     */\r\n    Sound.prototype.init = (function(_super) {\r\n      return function() {\r\n        var self = this;\r\n        var parent = self._parent;\r\n  \r\n        // Setup user-defined default properties.\r\n        self._orientation = parent._orientation;\r\n        self._stereo = parent._stereo;\r\n        self._pos = parent._pos;\r\n        self._pannerAttr = parent._pannerAttr;\r\n  \r\n        // Complete initilization with howler.js core Sound's init function.\r\n        _super.call(this);\r\n  \r\n        // If a stereo or position was specified, set it up.\r\n        if (self._stereo) {\r\n          parent.stereo(self._stereo);\r\n        } else if (self._pos) {\r\n          parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\r\n        }\r\n      };\r\n    })(Sound.prototype.init);\r\n  \r\n    /**\r\n     * Override the Sound.reset method to clean up properties from the spatial plugin.\r\n     * @param  {Function} _super Sound reset method.\r\n     * @return {Sound}\r\n     */\r\n    Sound.prototype.reset = (function(_super) {\r\n      return function() {\r\n        var self = this;\r\n        var parent = self._parent;\r\n  \r\n        // Reset all spatial plugin properties on this sound.\r\n        self._orientation = parent._orientation;\r\n        self._stereo = parent._stereo;\r\n        self._pos = parent._pos;\r\n        self._pannerAttr = parent._pannerAttr;\r\n  \r\n        // If a stereo or position was specified, set it up.\r\n        if (self._stereo) {\r\n          parent.stereo(self._stereo);\r\n        } else if (self._pos) {\r\n          parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\r\n        } else if (self._panner) {\r\n          // Disconnect the panner.\r\n          self._panner.disconnect(0);\r\n          self._panner = undefined;\r\n          parent._refreshBuffer(self);\r\n        }\r\n  \r\n        // Complete resetting of the sound.\r\n        return _super.call(this);\r\n      };\r\n    })(Sound.prototype.reset);\r\n  \r\n    /** Helper Methods **/\r\n    /***************************************************************************/\r\n  \r\n    /**\r\n     * Create a new panner node and save it on the sound.\r\n     * @param  {Sound} sound Specific sound to setup panning on.\r\n     * @param {String} type Type of panner to create: 'stereo' or 'spatial'.\r\n     */\r\n    var setupPanner = function(sound, type) {\r\n      type = type || 'spatial';\r\n  \r\n      // Create the new panner node.\r\n      if (type === 'spatial') {\r\n        sound._panner = Howler.ctx.createPanner();\r\n        sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;\r\n        sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;\r\n        sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;\r\n        sound._panner.distanceModel = sound._pannerAttr.distanceModel;\r\n        sound._panner.maxDistance = sound._pannerAttr.maxDistance;\r\n        sound._panner.refDistance = sound._pannerAttr.refDistance;\r\n        sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;\r\n        sound._panner.panningModel = sound._pannerAttr.panningModel;\r\n  \r\n        if (typeof sound._panner.positionX !== 'undefined') {\r\n          sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);\r\n          sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);\r\n          sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);\r\n        } else {\r\n          sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);\r\n        }\r\n  \r\n        if (typeof sound._panner.orientationX !== 'undefined') {\r\n          sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);\r\n          sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);\r\n          sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);\r\n        } else {\r\n          sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);\r\n        }\r\n      } else {\r\n        sound._panner = Howler.ctx.createStereoPanner();\r\n        sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);\r\n      }\r\n  \r\n      sound._panner.connect(sound._node);\r\n  \r\n      // Update the connections.\r\n      if (!sound._paused) {\r\n        sound._parent.pause(sound._id, true).play(sound._id, true);\r\n      }\r\n    };\r\n  })();\n\n//# sourceURL=webpack://hw2/./js/howlerSrc.js?");

/***/ }),

/***/ "./js/luxonSrc.js":
/*!************************!*\
  !*** ./js/luxonSrc.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DateTime\": () => (/* binding */ Wr),\n/* harmony export */   \"Duration\": () => (/* binding */ _t),\n/* harmony export */   \"FixedOffsetZone\": () => (/* binding */ Ve),\n/* harmony export */   \"IANAZone\": () => (/* binding */ De),\n/* harmony export */   \"Info\": () => (/* binding */ Rt),\n/* harmony export */   \"Interval\": () => (/* binding */ Wt),\n/* harmony export */   \"InvalidZone\": () => (/* binding */ Ie),\n/* harmony export */   \"Settings\": () => (/* binding */ qe),\n/* harmony export */   \"SystemZone\": () => (/* binding */ Oe),\n/* harmony export */   \"VERSION\": () => (/* binding */ Xe),\n/* harmony export */   \"Zone\": () => (/* binding */ Te)\n/* harmony export */ });\nclass e extends Error {}\r\nclass r extends e {\r\n    constructor(e) {\r\n        super(`Invalid DateTime: ${e.toMessage()}`)\r\n    }\r\n}\r\nclass n extends e {\r\n    constructor(e) {\r\n        super(`Invalid Interval: ${e.toMessage()}`)\r\n    }\r\n}\r\nclass s extends e {\r\n    constructor(e) {\r\n        super(`Invalid Duration: ${e.toMessage()}`)\r\n    }\r\n}\r\nclass N extends e {}\r\nclass i extends e {\r\n    constructor(e) {\r\n        super(`Invalid unit ${e}`)\r\n    }\r\n}\r\nclass a extends e {}\r\nclass o extends e {\r\n    constructor() {\r\n        super(\"Zone is an abstract class\")\r\n    }\r\n}\r\nvar t = \"numeric\",\r\n    u = \"short\",\r\n    l = \"long\";\r\nconst c = {\r\n        year: t,\r\n        month: t,\r\n        day: t\r\n    },\r\n    h = {\r\n        year: t,\r\n        month: u,\r\n        day: t\r\n    },\r\n    d = {\r\n        year: t,\r\n        month: u,\r\n        day: t,\r\n        weekday: u\r\n    },\r\n    m = {\r\n        year: t,\r\n        month: l,\r\n        day: t\r\n    },\r\n    f = {\r\n        year: t,\r\n        month: l,\r\n        day: t,\r\n        weekday: l\r\n    },\r\n    y = {\r\n        hour: t,\r\n        minute: t\r\n    },\r\n    g = {\r\n        hour: t,\r\n        minute: t,\r\n        second: t\r\n    },\r\n    w = {\r\n        hour: t,\r\n        minute: t,\r\n        second: t,\r\n        timeZoneName: u\r\n    },\r\n    p = {\r\n        hour: t,\r\n        minute: t,\r\n        second: t,\r\n        timeZoneName: l\r\n    },\r\n    v = {\r\n        hour: t,\r\n        minute: t,\r\n        hourCycle: \"h23\"\r\n    },\r\n    T = {\r\n        hour: t,\r\n        minute: t,\r\n        second: t,\r\n        hourCycle: \"h23\"\r\n    },\r\n    S = {\r\n        hour: t,\r\n        minute: t,\r\n        second: t,\r\n        hourCycle: \"h23\",\r\n        timeZoneName: u\r\n    },\r\n    O = {\r\n        hour: t,\r\n        minute: t,\r\n        second: t,\r\n        hourCycle: \"h23\",\r\n        timeZoneName: l\r\n    },\r\n    b = {\r\n        year: t,\r\n        month: t,\r\n        day: t,\r\n        hour: t,\r\n        minute: t\r\n    },\r\n    M = {\r\n        year: t,\r\n        month: t,\r\n        day: t,\r\n        hour: t,\r\n        minute: t,\r\n        second: t\r\n    },\r\n    k = {\r\n        year: t,\r\n        month: u,\r\n        day: t,\r\n        hour: t,\r\n        minute: t\r\n    },\r\n    D = {\r\n        year: t,\r\n        month: u,\r\n        day: t,\r\n        hour: t,\r\n        minute: t,\r\n        second: t\r\n    },\r\n    E = {\r\n        year: t,\r\n        month: u,\r\n        day: t,\r\n        weekday: u,\r\n        hour: t,\r\n        minute: t\r\n    },\r\n    V = {\r\n        year: t,\r\n        month: l,\r\n        day: t,\r\n        hour: t,\r\n        minute: t,\r\n        timeZoneName: u\r\n    },\r\n    I = {\r\n        year: t,\r\n        month: l,\r\n        day: t,\r\n        hour: t,\r\n        minute: t,\r\n        second: t,\r\n        timeZoneName: u\r\n    },\r\n    x = {\r\n        year: t,\r\n        month: l,\r\n        day: t,\r\n        weekday: l,\r\n        hour: t,\r\n        minute: t,\r\n        timeZoneName: l\r\n    },\r\n    C = {\r\n        year: t,\r\n        month: l,\r\n        day: t,\r\n        weekday: l,\r\n        hour: t,\r\n        minute: t,\r\n        second: t,\r\n        timeZoneName: l\r\n    };\r\n\r\nfunction $(e) {\r\n    return void 0 === e\r\n}\r\n\r\nfunction Z(e) {\r\n    return \"number\" == typeof e\r\n}\r\n\r\nfunction F(e) {\r\n    return \"number\" == typeof e && e % 1 == 0\r\n}\r\n\r\nfunction L() {\r\n    try {\r\n        return \"undefined\" != typeof Intl && !!Intl.RelativeTimeFormat\r\n    } catch (e) {\r\n        return !1\r\n    }\r\n}\r\n\r\nfunction z(e, r, n) {\r\n    if (0 !== e.length) return e.reduce((e, t) => {\r\n        t = [r(t), t];\r\n        return e && n(e[0], t[0]) === e[0] ? e : t\r\n    }, null)[1]\r\n}\r\n\r\nfunction q(e, t) {\r\n    return Object.prototype.hasOwnProperty.call(e, t)\r\n}\r\n\r\nfunction A(e, t, r) {\r\n    return F(e) && t <= e && e <= r\r\n}\r\n\r\nfunction j(e, t = 2) {\r\n    var r = e < 0 ? \"-\" : \"\";\r\n    const n = r ? -1 * e : e;\r\n    let s;\r\n    return s = n.toString().length < t ? (\"0\".repeat(t) + n).slice(-t) : n.toString(), `${r}${s}`\r\n}\r\n\r\nfunction _(e) {\r\n    if (!$(e) && null !== e && \"\" !== e) return parseInt(e, 10)\r\n}\r\n\r\nfunction U(e) {\r\n    if (!$(e) && null !== e && \"\" !== e) {\r\n        e = 1e3 * parseFloat(\"0.\" + e);\r\n        return Math.floor(e)\r\n    }\r\n}\r\n\r\nfunction H(e, t, r = !1) {\r\n    const n = 10 ** t,\r\n        s = r ? Math.trunc : Math.round;\r\n    return s(e * n) / n\r\n}\r\n\r\nfunction W(e) {\r\n    return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0)\r\n}\r\n\r\nfunction R(e) {\r\n    return W(e) ? 366 : 365\r\n}\r\n\r\nfunction P(e, t) {\r\n    var r, n, n = (r = t - 1) - (n = 12) * Math.floor(r / n) + 1;\r\n    return 2 == n ? W(e + (t - n) / 12) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][n - 1]\r\n}\r\n\r\nfunction J(e) {\r\n    let t = Date.UTC(e.year, e.month - 1, e.day, e.hour, e.minute, e.second, e.millisecond);\r\n    return e.year < 100 && 0 <= e.year && (t = new Date(t), t.setUTCFullYear(t.getUTCFullYear() - 1900)), +t\r\n}\r\n\r\nfunction Y(e) {\r\n    var t = (e + Math.floor(e / 4) - Math.floor(e / 100) + Math.floor(e / 400)) % 7,\r\n        e = e - 1,\r\n        e = (e + Math.floor(e / 4) - Math.floor(e / 100) + Math.floor(e / 400)) % 7;\r\n    return 4 == t || 3 == e ? 53 : 52\r\n}\r\n\r\nfunction G(e) {\r\n    return 99 < e ? e : 60 < e ? 1900 + e : 2e3 + e\r\n}\r\n\r\nfunction B(e, t, r, n = null) {\r\n    const s = new Date(e),\r\n        i = {\r\n            hourCycle: \"h23\",\r\n            year: \"numeric\",\r\n            month: \"2-digit\",\r\n            day: \"2-digit\",\r\n            hour: \"2-digit\",\r\n            minute: \"2-digit\"\r\n        };\r\n    n && (i.timeZone = n);\r\n    t = {\r\n        timeZoneName: t,\r\n        ...i\r\n    }, t = new Intl.DateTimeFormat(r, t).formatToParts(s).find(e => \"timezonename\" === e.type.toLowerCase());\r\n    return t ? t.value : null\r\n}\r\n\r\nfunction Q(e, t) {\r\n    let r = parseInt(e, 10);\r\n    Number.isNaN(r) && (r = 0);\r\n    t = parseInt(t, 10) || 0, t = r < 0 || Object.is(r, -0) ? -t : t;\r\n    return 60 * r + t\r\n}\r\n\r\nfunction K(e) {\r\n    var t = Number(e);\r\n    if (\"boolean\" == typeof e || \"\" === e || Number.isNaN(t)) throw new a(`Invalid unit value ${e}`);\r\n    return t\r\n}\r\n\r\nfunction X(e, t) {\r\n    const r = {};\r\n    for (const s in e) {\r\n        var n;\r\n        !q(e, s) || null != (n = e[s]) && (r[t(s)] = K(n))\r\n    }\r\n    return r\r\n}\r\n\r\nfunction ee(e, t) {\r\n    var r = Math.trunc(Math.abs(e / 60)),\r\n        n = Math.trunc(Math.abs(e % 60)),\r\n        s = 0 <= e ? \"+\" : \"-\";\r\n    switch (t) {\r\n        case \"short\":\r\n            return `${s}${j(r,2)}:${j(n,2)}`;\r\n        case \"narrow\":\r\n            return `${s}${r}${0<n?`:${n}`:\"\"}`;\r\n        case \"techie\":\r\n            return `${s}${j(r,2)}${j(n,2)}`;\r\n        default:\r\n            throw new RangeError(`Value format ${t} is out of range for property format`)\r\n    }\r\n}\r\n\r\nfunction te(e) {\r\n    return r = e, [\"hour\", \"minute\", \"second\", \"millisecond\"].reduce((e, t) => (e[t] = r[t], e), {});\r\n    var r\r\n}\r\nvar re = /[A-Za-z_+-]{1,256}(:?\\/[A-Za-z_+-]{1,256}(\\/[A-Za-z_+-]{1,256})?)?/;\r\nconst ne = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\r\n    se = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\r\n    ie = [\"J\", \"F\", \"M\", \"A\", \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"];\r\n\r\nfunction ae(e) {\r\n    switch (e) {\r\n        case \"narrow\":\r\n            return [...ie];\r\n        case \"short\":\r\n            return [...se];\r\n        case \"long\":\r\n            return [...ne];\r\n        case \"numeric\":\r\n            return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"];\r\n        case \"2-digit\":\r\n            return [\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\"];\r\n        default:\r\n            return null\r\n    }\r\n}\r\nconst oe = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"],\r\n    ue = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"],\r\n    le = [\"M\", \"T\", \"W\", \"T\", \"F\", \"S\", \"S\"];\r\n\r\nfunction ce(e) {\r\n    switch (e) {\r\n        case \"narrow\":\r\n            return [...le];\r\n        case \"short\":\r\n            return [...ue];\r\n        case \"long\":\r\n            return [...oe];\r\n        case \"numeric\":\r\n            return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"];\r\n        default:\r\n            return null\r\n    }\r\n}\r\nconst he = [\"AM\", \"PM\"],\r\n    de = [\"Before Christ\", \"Anno Domini\"],\r\n    me = [\"BC\", \"AD\"],\r\n    fe = [\"B\", \"A\"];\r\n\r\nfunction ye(e) {\r\n    switch (e) {\r\n        case \"narrow\":\r\n            return [...fe];\r\n        case \"short\":\r\n            return [...me];\r\n        case \"long\":\r\n            return [...de];\r\n        default:\r\n            return null\r\n    }\r\n}\r\n\r\nfunction ge(e, t) {\r\n    let r = \"\";\r\n    for (const n of e) n.literal ? r += n.val : r += t(n.val);\r\n    return r\r\n}\r\nconst we = {\r\n    D: c,\r\n    DD: h,\r\n    DDD: m,\r\n    DDDD: f,\r\n    t: y,\r\n    tt: g,\r\n    ttt: w,\r\n    tttt: p,\r\n    T: v,\r\n    TT: T,\r\n    TTT: S,\r\n    TTTT: O,\r\n    f: b,\r\n    ff: k,\r\n    fff: V,\r\n    ffff: x,\r\n    F: M,\r\n    FF: D,\r\n    FFF: I,\r\n    FFFF: C\r\n};\r\nclass pe {\r\n    static create(e, t = {}) {\r\n        return new pe(e, t)\r\n    }\r\n    static parseFormat(t) {\r\n        let r = null,\r\n            n = \"\",\r\n            s = !1;\r\n        const i = [];\r\n        for (let e = 0; e < t.length; e++) {\r\n            var a = t.charAt(e);\r\n            \"'\" === a ? (0 < n.length && i.push({\r\n                literal: s,\r\n                val: n\r\n            }), r = null, n = \"\", s = !s) : s || a === r ? n += a : (0 < n.length && i.push({\r\n                literal: !1,\r\n                val: n\r\n            }), n = a, r = a)\r\n        }\r\n        return 0 < n.length && i.push({\r\n            literal: s,\r\n            val: n\r\n        }), i\r\n    }\r\n    static macroTokenToFormatOpts(e) {\r\n        return we[e]\r\n    }\r\n    constructor(e, t) {\r\n        this.opts = t, this.loc = e, this.systemLoc = null\r\n    }\r\n    formatWithSystemDefault(e, t) {\r\n        null === this.systemLoc && (this.systemLoc = this.loc.redefaultToSystem());\r\n        const r = this.systemLoc.dtFormatter(e, {\r\n            ...this.opts,\r\n            ...t\r\n        });\r\n        return r.format()\r\n    }\r\n    formatDateTime(e, t = {}) {\r\n        const r = this.loc.dtFormatter(e, {\r\n            ...this.opts,\r\n            ...t\r\n        });\r\n        return r.format()\r\n    }\r\n    formatDateTimeParts(e, t = {}) {\r\n        const r = this.loc.dtFormatter(e, {\r\n            ...this.opts,\r\n            ...t\r\n        });\r\n        return r.formatToParts()\r\n    }\r\n    resolvedOptions(e, t = {}) {\r\n        const r = this.loc.dtFormatter(e, {\r\n            ...this.opts,\r\n            ...t\r\n        });\r\n        return r.resolvedOptions()\r\n    }\r\n    num(e, t = 0) {\r\n        if (this.opts.forceSimple) return j(e, t);\r\n        const r = {\r\n            ...this.opts\r\n        };\r\n        return 0 < t && (r.padTo = t), this.loc.numberFormatter(r).format(e)\r\n    }\r\n    formatDateTimeFromString(r, e) {\r\n        const n = \"en\" === this.loc.listingMode(),\r\n            t = this.loc.outputCalendar && \"gregory\" !== this.loc.outputCalendar,\r\n            s = (e, t) => this.loc.extract(r, e, t),\r\n            i = e => r.isOffsetFixed && 0 === r.offset && e.allowZ ? \"Z\" : r.isValid ? r.zone.formatOffset(r.ts, e.format) : \"\",\r\n            a = () => n ? function (e) {\r\n                return he[e.hour < 12 ? 0 : 1]\r\n            }(r) : s({\r\n                hour: \"numeric\",\r\n                hourCycle: \"h12\"\r\n            }, \"dayperiod\"),\r\n            o = (e, t) => n ? function (e, t) {\r\n                return ae(t)[e.month - 1]\r\n            }(r, e) : s(t ? {\r\n                month: e\r\n            } : {\r\n                month: e,\r\n                day: \"numeric\"\r\n            }, \"month\"),\r\n            u = (e, t) => n ? function (e, t) {\r\n                return ce(t)[e.weekday - 1]\r\n            }(r, e) : s(t ? {\r\n                weekday: e\r\n            } : {\r\n                weekday: e,\r\n                month: \"long\",\r\n                day: \"numeric\"\r\n            }, \"weekday\"),\r\n            l = e => {\r\n                var t = pe.macroTokenToFormatOpts(e);\r\n                return t ? this.formatWithSystemDefault(r, t) : e\r\n            },\r\n            c = e => n ? function (e, t) {\r\n                return ye(t)[e.year < 0 ? 0 : 1]\r\n            }(r, e) : s({\r\n                era: e\r\n            }, \"era\");\r\n        return ge(pe.parseFormat(e), e => {\r\n            switch (e) {\r\n                case \"S\":\r\n                    return this.num(r.millisecond);\r\n                case \"u\":\r\n                case \"SSS\":\r\n                    return this.num(r.millisecond, 3);\r\n                case \"s\":\r\n                    return this.num(r.second);\r\n                case \"ss\":\r\n                    return this.num(r.second, 2);\r\n                case \"m\":\r\n                    return this.num(r.minute);\r\n                case \"mm\":\r\n                    return this.num(r.minute, 2);\r\n                case \"h\":\r\n                    return this.num(r.hour % 12 == 0 ? 12 : r.hour % 12);\r\n                case \"hh\":\r\n                    return this.num(r.hour % 12 == 0 ? 12 : r.hour % 12, 2);\r\n                case \"H\":\r\n                    return this.num(r.hour);\r\n                case \"HH\":\r\n                    return this.num(r.hour, 2);\r\n                case \"Z\":\r\n                    return i({\r\n                        format: \"narrow\",\r\n                        allowZ: this.opts.allowZ\r\n                    });\r\n                case \"ZZ\":\r\n                    return i({\r\n                        format: \"short\",\r\n                        allowZ: this.opts.allowZ\r\n                    });\r\n                case \"ZZZ\":\r\n                    return i({\r\n                        format: \"techie\",\r\n                        allowZ: this.opts.allowZ\r\n                    });\r\n                case \"ZZZZ\":\r\n                    return r.zone.offsetName(r.ts, {\r\n                        format: \"short\",\r\n                        locale: this.loc.locale\r\n                    });\r\n                case \"ZZZZZ\":\r\n                    return r.zone.offsetName(r.ts, {\r\n                        format: \"long\",\r\n                        locale: this.loc.locale\r\n                    });\r\n                case \"z\":\r\n                    return r.zoneName;\r\n                case \"a\":\r\n                    return a();\r\n                case \"d\":\r\n                    return t ? s({\r\n                        day: \"numeric\"\r\n                    }, \"day\") : this.num(r.day);\r\n                case \"dd\":\r\n                    return t ? s({\r\n                        day: \"2-digit\"\r\n                    }, \"day\") : this.num(r.day, 2);\r\n                case \"c\":\r\n                    return this.num(r.weekday);\r\n                case \"ccc\":\r\n                    return u(\"short\", !0);\r\n                case \"cccc\":\r\n                    return u(\"long\", !0);\r\n                case \"ccccc\":\r\n                    return u(\"narrow\", !0);\r\n                case \"E\":\r\n                    return this.num(r.weekday);\r\n                case \"EEE\":\r\n                    return u(\"short\", !1);\r\n                case \"EEEE\":\r\n                    return u(\"long\", !1);\r\n                case \"EEEEE\":\r\n                    return u(\"narrow\", !1);\r\n                case \"L\":\r\n                    return t ? s({\r\n                        month: \"numeric\",\r\n                        day: \"numeric\"\r\n                    }, \"month\") : this.num(r.month);\r\n                case \"LL\":\r\n                    return t ? s({\r\n                        month: \"2-digit\",\r\n                        day: \"numeric\"\r\n                    }, \"month\") : this.num(r.month, 2);\r\n                case \"LLL\":\r\n                    return o(\"short\", !0);\r\n                case \"LLLL\":\r\n                    return o(\"long\", !0);\r\n                case \"LLLLL\":\r\n                    return o(\"narrow\", !0);\r\n                case \"M\":\r\n                    return t ? s({\r\n                        month: \"numeric\"\r\n                    }, \"month\") : this.num(r.month);\r\n                case \"MM\":\r\n                    return t ? s({\r\n                        month: \"2-digit\"\r\n                    }, \"month\") : this.num(r.month, 2);\r\n                case \"MMM\":\r\n                    return o(\"short\", !1);\r\n                case \"MMMM\":\r\n                    return o(\"long\", !1);\r\n                case \"MMMMM\":\r\n                    return o(\"narrow\", !1);\r\n                case \"y\":\r\n                    return t ? s({\r\n                        year: \"numeric\"\r\n                    }, \"year\") : this.num(r.year);\r\n                case \"yy\":\r\n                    return t ? s({\r\n                        year: \"2-digit\"\r\n                    }, \"year\") : this.num(r.year.toString().slice(-2), 2);\r\n                case \"yyyy\":\r\n                    return t ? s({\r\n                        year: \"numeric\"\r\n                    }, \"year\") : this.num(r.year, 4);\r\n                case \"yyyyyy\":\r\n                    return t ? s({\r\n                        year: \"numeric\"\r\n                    }, \"year\") : this.num(r.year, 6);\r\n                case \"G\":\r\n                    return c(\"short\");\r\n                case \"GG\":\r\n                    return c(\"long\");\r\n                case \"GGGGG\":\r\n                    return c(\"narrow\");\r\n                case \"kk\":\r\n                    return this.num(r.weekYear.toString().slice(-2), 2);\r\n                case \"kkkk\":\r\n                    return this.num(r.weekYear, 4);\r\n                case \"W\":\r\n                    return this.num(r.weekNumber);\r\n                case \"WW\":\r\n                    return this.num(r.weekNumber, 2);\r\n                case \"o\":\r\n                    return this.num(r.ordinal);\r\n                case \"ooo\":\r\n                    return this.num(r.ordinal, 3);\r\n                case \"q\":\r\n                    return this.num(r.quarter);\r\n                case \"qq\":\r\n                    return this.num(r.quarter, 2);\r\n                case \"X\":\r\n                    return this.num(Math.floor(r.ts / 1e3));\r\n                case \"x\":\r\n                    return this.num(r.ts);\r\n                default:\r\n                    return l(e)\r\n            }\r\n        })\r\n    }\r\n    formatDurationFromString(e, t) {\r\n        const r = e => {\r\n                switch (e[0]) {\r\n                    case \"S\":\r\n                        return \"millisecond\";\r\n                    case \"s\":\r\n                        return \"second\";\r\n                    case \"m\":\r\n                        return \"minute\";\r\n                    case \"h\":\r\n                        return \"hour\";\r\n                    case \"d\":\r\n                        return \"day\";\r\n                    case \"M\":\r\n                        return \"month\";\r\n                    case \"y\":\r\n                        return \"year\";\r\n                    default:\r\n                        return null\r\n                }\r\n            },\r\n            n = pe.parseFormat(t),\r\n            s = n.reduce((e, {\r\n                literal: t,\r\n                val: r\r\n            }) => t ? e : e.concat(r), []),\r\n            i = e.shiftTo(...s.map(r).filter(e => e));\r\n        return ge(n, (a = i, e => {\r\n            var t = r(e);\r\n            return t ? this.num(a.get(t), e.length) : e\r\n        }));\r\n        var a\r\n    }\r\n}\r\nclass ve {\r\n    constructor(e, t) {\r\n        this.reason = e, this.explanation = t\r\n    }\r\n    toMessage() {\r\n        return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason\r\n    }\r\n}\r\nclass Te {\r\n    get type() {\r\n        throw new o\r\n    }\r\n    get name() {\r\n        throw new o\r\n    }\r\n    get isUniversal() {\r\n        throw new o\r\n    }\r\n    offsetName(e, t) {\r\n        throw new o\r\n    }\r\n    formatOffset(e, t) {\r\n        throw new o\r\n    }\r\n    offset(e) {\r\n        throw new o\r\n    }\r\n    equals(e) {\r\n        throw new o\r\n    }\r\n    get isValid() {\r\n        throw new o\r\n    }\r\n}\r\nlet Se = null;\r\nclass Oe extends Te {\r\n    static get instance() {\r\n        return null === Se && (Se = new Oe), Se\r\n    }\r\n    get type() {\r\n        return \"system\"\r\n    }\r\n    get name() {\r\n        return (new Intl.DateTimeFormat).resolvedOptions().timeZone\r\n    }\r\n    get isUniversal() {\r\n        return !1\r\n    }\r\n    offsetName(e, {\r\n        format: t,\r\n        locale: r\r\n    }) {\r\n        return B(e, t, r)\r\n    }\r\n    formatOffset(e, t) {\r\n        return ee(this.offset(e), t)\r\n    }\r\n    offset(e) {\r\n        return -new Date(e).getTimezoneOffset()\r\n    }\r\n    equals(e) {\r\n        return \"system\" === e.type\r\n    }\r\n    get isValid() {\r\n        return !0\r\n    }\r\n}\r\nconst be = RegExp(`^${re.source}$`);\r\nlet Me = {};\r\nconst ke = {\r\n    year: 0,\r\n    month: 1,\r\n    day: 2,\r\n    hour: 3,\r\n    minute: 4,\r\n    second: 5\r\n};\r\nlet Ne = {};\r\nclass De extends Te {\r\n    static create(e) {\r\n        return Ne[e] || (Ne[e] = new De(e)), Ne[e]\r\n    }\r\n    static resetCache() {\r\n        Ne = {}, Me = {}\r\n    }\r\n    static isValidSpecifier(e) {\r\n        return !(!e || !e.match(be))\r\n    }\r\n    static isValidZone(e) {\r\n        try {\r\n            return new Intl.DateTimeFormat(\"en-US\", {\r\n                timeZone: e\r\n            }).format(), !0\r\n        } catch (e) {\r\n            return !1\r\n        }\r\n    }\r\n    static parseGMTOffset(e) {\r\n        if (e) {\r\n            e = e.match(/^Etc\\/GMT(0|[+-]\\d{1,2})$/i);\r\n            if (e) return -60 * parseInt(e[1])\r\n        }\r\n        return null\r\n    }\r\n    constructor(e) {\r\n        super(), this.zoneName = e, this.valid = De.isValidZone(e)\r\n    }\r\n    get type() {\r\n        return \"iana\"\r\n    }\r\n    get name() {\r\n        return this.zoneName\r\n    }\r\n    get isUniversal() {\r\n        return !1\r\n    }\r\n    offsetName(e, {\r\n        format: t,\r\n        locale: r\r\n    }) {\r\n        return B(e, t, r, this.name)\r\n    }\r\n    formatOffset(e, t) {\r\n        return ee(this.offset(e), t)\r\n    }\r\n    offset(e) {\r\n        var t = new Date(e);\r\n        if (isNaN(t)) return NaN;\r\n        var r = (o = this.name, Me[o] || (Me[o] = new Intl.DateTimeFormat(\"en-US\", {\r\n                hourCycle: \"h23\",\r\n                timeZone: o,\r\n                year: \"numeric\",\r\n                month: \"2-digit\",\r\n                day: \"2-digit\",\r\n                hour: \"2-digit\",\r\n                minute: \"2-digit\",\r\n                second: \"2-digit\"\r\n            })), Me[o]),\r\n            [n, s, i, a, e, o] = (r.formatToParts ? function (e, t) {\r\n                const r = e.formatToParts(t),\r\n                    n = [];\r\n                for (let e = 0; e < r.length; e++) {\r\n                    var {\r\n                        type: s,\r\n                        value: i\r\n                    } = r[e], s = ke[s];\r\n                    $(s) || (n[s] = parseInt(i, 10))\r\n                }\r\n                return n\r\n            } : function (e, t) {\r\n                var r = e.format(t).replace(/\\u200E/g, \"\"),\r\n                    [, n, s, i, e, t, r] = /(\\d+)\\/(\\d+)\\/(\\d+),? (\\d+):(\\d+):(\\d+)/.exec(r);\r\n                return [i, n, s, e, t, r]\r\n            })(r, t),\r\n            r = +t,\r\n            t = r % 1e3;\r\n        return (J({\r\n            year: n,\r\n            month: s,\r\n            day: i,\r\n            hour: a,\r\n            minute: e,\r\n            second: o,\r\n            millisecond: 0\r\n        }) - (r -= 0 <= t ? t : 1e3 + t)) / 6e4\r\n    }\r\n    equals(e) {\r\n        return \"iana\" === e.type && e.name === this.name\r\n    }\r\n    get isValid() {\r\n        return this.valid\r\n    }\r\n}\r\nlet Ee = null;\r\nclass Ve extends Te {\r\n    static get utcInstance() {\r\n        return null === Ee && (Ee = new Ve(0)), Ee\r\n    }\r\n    static instance(e) {\r\n        return 0 === e ? Ve.utcInstance : new Ve(e)\r\n    }\r\n    static parseSpecifier(e) {\r\n        if (e) {\r\n            e = e.match(/^utc(?:([+-]\\d{1,2})(?::(\\d{2}))?)?$/i);\r\n            if (e) return new Ve(Q(e[1], e[2]))\r\n        }\r\n        return null\r\n    }\r\n    constructor(e) {\r\n        super(), this.fixed = e\r\n    }\r\n    get type() {\r\n        return \"fixed\"\r\n    }\r\n    get name() {\r\n        return 0 === this.fixed ? \"UTC\" : `UTC${ee(this.fixed,\"narrow\")}`\r\n    }\r\n    offsetName() {\r\n        return this.name\r\n    }\r\n    formatOffset(e, t) {\r\n        return ee(this.fixed, t)\r\n    }\r\n    get isUniversal() {\r\n        return !0\r\n    }\r\n    offset() {\r\n        return this.fixed\r\n    }\r\n    equals(e) {\r\n        return \"fixed\" === e.type && e.fixed === this.fixed\r\n    }\r\n    get isValid() {\r\n        return !0\r\n    }\r\n}\r\nclass Ie extends Te {\r\n    constructor(e) {\r\n        super(), this.zoneName = e\r\n    }\r\n    get type() {\r\n        return \"invalid\"\r\n    }\r\n    get name() {\r\n        return this.zoneName\r\n    }\r\n    get isUniversal() {\r\n        return !1\r\n    }\r\n    offsetName() {\r\n        return null\r\n    }\r\n    formatOffset() {\r\n        return \"\"\r\n    }\r\n    offset() {\r\n        return NaN\r\n    }\r\n    equals() {\r\n        return !1\r\n    }\r\n    get isValid() {\r\n        return !1\r\n    }\r\n}\r\n\r\nfunction xe(e, t) {\r\n    if ($(e) || null === e) return t;\r\n    if (e instanceof Te) return e;\r\n    if (\"string\" != typeof e) return Z(e) ? Ve.instance(e) : \"object\" == typeof e && e.offset && \"number\" == typeof e.offset ? e : new Ie(e);\r\n    var r = e.toLowerCase();\r\n    return \"local\" === r || \"system\" === r ? t : \"utc\" === r || \"gmt\" === r ? Ve.utcInstance : null != (t = De.parseGMTOffset(e)) ? Ve.instance(t) : De.isValidSpecifier(r) ? De.create(e) : Ve.parseSpecifier(r) || new Ie(e)\r\n}\r\nlet Ce = () => Date.now(),\r\n    $e = \"system\",\r\n    Ze = null,\r\n    Fe = null,\r\n    Le = null,\r\n    ze;\r\nclass qe {\r\n    static get now() {\r\n        return Ce\r\n    }\r\n    static set now(e) {\r\n        Ce = e\r\n    }\r\n    static set defaultZone(e) {\r\n        $e = e\r\n    }\r\n    static get defaultZone() {\r\n        return xe($e, Oe.instance)\r\n    }\r\n    static get defaultLocale() {\r\n        return Ze\r\n    }\r\n    static set defaultLocale(e) {\r\n        Ze = e\r\n    }\r\n    static get defaultNumberingSystem() {\r\n        return Fe\r\n    }\r\n    static set defaultNumberingSystem(e) {\r\n        Fe = e\r\n    }\r\n    static get defaultOutputCalendar() {\r\n        return Le\r\n    }\r\n    static set defaultOutputCalendar(e) {\r\n        Le = e\r\n    }\r\n    static get throwOnInvalid() {\r\n        return ze\r\n    }\r\n    static set throwOnInvalid(e) {\r\n        ze = e\r\n    }\r\n    static resetCaches() {\r\n        Ye.resetCache(), De.resetCache()\r\n    }\r\n}\r\nlet Ae = {};\r\n\r\nfunction je(e, t = {}) {\r\n    var r = JSON.stringify([e, t]);\r\n    let n = Ae[r];\r\n    return n || (n = new Intl.DateTimeFormat(e, t), Ae[r] = n), n\r\n}\r\nlet _e = {};\r\nlet Ue = {};\r\nlet He = null;\r\n\r\nfunction We(e, t, r, n, s) {\r\n    r = e.listingMode(r);\r\n    return \"error\" === r ? null : (\"en\" === r ? n : s)(t)\r\n}\r\nclass Re {\r\n    constructor(e, t, r) {\r\n        if (this.padTo = r.padTo || 0, this.floor = r.floor || !1, !t) {\r\n            const n = {\r\n                useGrouping: !1\r\n            };\r\n            0 < r.padTo && (n.minimumIntegerDigits = r.padTo), this.inf = function (e, t = {}) {\r\n                var r = JSON.stringify([e, t]);\r\n                let n = _e[r];\r\n                return n || (n = new Intl.NumberFormat(e, t), _e[r] = n), n\r\n            }(e, n)\r\n        }\r\n    }\r\n    format(e) {\r\n        if (this.inf) {\r\n            var t = this.floor ? Math.floor(e) : e;\r\n            return this.inf.format(t)\r\n        }\r\n        return j(this.floor ? Math.floor(e) : H(e, 3), this.padTo)\r\n    }\r\n}\r\nclass Pe {\r\n    constructor(e, t, r) {\r\n        this.opts = r;\r\n        let n;\r\n        var s, i;\r\n        e.zone.isUniversal ? (s = 0 <= (i = e.offset / 60 * -1) ? `Etc/GMT+${i}` : `Etc/GMT${i}`, i = De.isValidZone(s), 0 !== e.offset && i ? (n = s, this.dt = e) : (n = \"UTC\", r.timeZoneName ? this.dt = e : this.dt = 0 === e.offset ? e : Wr.fromMillis(e.ts + 60 * e.offset * 1e3))) : \"system\" === e.zone.type ? this.dt = e : (this.dt = e, n = e.zone.name);\r\n        const a = {\r\n            ...this.opts\r\n        };\r\n        n && (a.timeZone = n), this.dtf = je(t, a)\r\n    }\r\n    format() {\r\n        return this.dtf.format(this.dt.toJSDate())\r\n    }\r\n    formatToParts() {\r\n        return this.dtf.formatToParts(this.dt.toJSDate())\r\n    }\r\n    resolvedOptions() {\r\n        return this.dtf.resolvedOptions()\r\n    }\r\n}\r\nclass Je {\r\n    constructor(e, t, r) {\r\n        this.opts = {\r\n            style: \"long\",\r\n            ...r\r\n        }, !t && L() && (this.rtf = function (e, t = {}) {\r\n            const {\r\n                base: r,\r\n                ...n\r\n            } = t;\r\n            var s = JSON.stringify([e, n]);\r\n            let i = Ue[s];\r\n            return i || (i = new Intl.RelativeTimeFormat(e, t), Ue[s] = i), i\r\n        }(e, r))\r\n    }\r\n    format(e, t) {\r\n        return this.rtf ? this.rtf.format(e, t) : function (e, t, r = \"always\", n) {\r\n            var s = {\r\n                    years: [\"year\", \"yr.\"],\r\n                    quarters: [\"quarter\", \"qtr.\"],\r\n                    months: [\"month\", \"mo.\"],\r\n                    weeks: [\"week\", \"wk.\"],\r\n                    days: [\"day\", \"day\", \"days\"],\r\n                    hours: [\"hour\", \"hr.\"],\r\n                    minutes: [\"minute\", \"min.\"],\r\n                    seconds: [\"second\", \"sec.\"]\r\n                },\r\n                i = -1 === [\"hours\", \"minutes\", \"seconds\"].indexOf(e);\r\n            if (\"auto\" === r && i) {\r\n                var a = \"days\" === e;\r\n                switch (t) {\r\n                    case 1:\r\n                        return a ? \"tomorrow\" : `next ${s[e][0]}`;\r\n                    case -1:\r\n                        return a ? \"yesterday\" : `last ${s[e][0]}`;\r\n                    case 0:\r\n                        return a ? \"today\" : `this ${s[e][0]}`\r\n                }\r\n            }\r\n            var o = Object.is(t, -0) || t < 0,\r\n                i = 1 === (r = Math.abs(t)),\r\n                t = s[e],\r\n                i = n ? !i && t[2] || t[1] : i ? s[e][0] : e;\r\n            return o ? `${r} ${i} ago` : `in ${r} ${i}`\r\n        }(t, e, this.opts.numeric, \"long\" !== this.opts.style)\r\n    }\r\n    formatToParts(e, t) {\r\n        return this.rtf ? this.rtf.formatToParts(e, t) : []\r\n    }\r\n}\r\nclass Ye {\r\n    static fromOpts(e) {\r\n        return Ye.create(e.locale, e.numberingSystem, e.outputCalendar, e.defaultToEN)\r\n    }\r\n    static create(e, t, r, n = !1) {\r\n        e = e || qe.defaultLocale, n = e || (n ? \"en-US\" : He || (He = (new Intl.DateTimeFormat).resolvedOptions().locale, He)), t = t || qe.defaultNumberingSystem, r = r || qe.defaultOutputCalendar;\r\n        return new Ye(n, t, r, e)\r\n    }\r\n    static resetCache() {\r\n        He = null, Ae = {}, _e = {}, Ue = {}\r\n    }\r\n    static fromObject({\r\n        locale: e,\r\n        numberingSystem: t,\r\n        outputCalendar: r\r\n    } = {}) {\r\n        return Ye.create(e, t, r)\r\n    }\r\n    constructor(e, t, r, n) {\r\n        var [s, i, e] = function (e) {\r\n            if (-1 === (n = e.indexOf(\"-u-\"))) return [e]; {\r\n                let t;\r\n                var r = e.substring(0, n);\r\n                try {\r\n                    t = je(e).resolvedOptions()\r\n                } catch (e) {\r\n                    t = je(r).resolvedOptions()\r\n                }\r\n                var {\r\n                    numberingSystem: n,\r\n                    calendar: e\r\n                } = t;\r\n                return [r, n, e]\r\n            }\r\n        }(e);\r\n        this.locale = s, this.numberingSystem = t || i || null, this.outputCalendar = r || e || null, this.intl = (i = this.locale, r = this.numberingSystem, ((e = this.outputCalendar) || r) && (i += \"-u\", e && (i += `-ca-${e}`), r && (i += `-nu-${r}`)), i), this.weekdaysCache = {\r\n            format: {},\r\n            standalone: {}\r\n        }, this.monthsCache = {\r\n            format: {},\r\n            standalone: {}\r\n        }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = n, this.fastNumbersCached = null\r\n    }\r\n    get fastNumbers() {\r\n        var e;\r\n        return null == this.fastNumbersCached && (this.fastNumbersCached = (!(e = this).numberingSystem || \"latn\" === e.numberingSystem) && (\"latn\" === e.numberingSystem || !e.locale || e.locale.startsWith(\"en\") || \"latn\" === new Intl.DateTimeFormat(e.intl).resolvedOptions().numberingSystem)), this.fastNumbersCached\r\n    }\r\n    listingMode(e = 0) {\r\n        var t = this.isEnglish(),\r\n            r = !(null !== this.numberingSystem && \"latn\" !== this.numberingSystem || null !== this.outputCalendar && \"gregory\" !== this.outputCalendar);\r\n        return t && r ? \"en\" : \"intl\"\r\n    }\r\n    clone(e) {\r\n        return e && 0 !== Object.getOwnPropertyNames(e).length ? Ye.create(e.locale || this.specifiedLocale, e.numberingSystem || this.numberingSystem, e.outputCalendar || this.outputCalendar, e.defaultToEN || !1) : this\r\n    }\r\n    redefaultToEN(e = {}) {\r\n        return this.clone({\r\n            ...e,\r\n            defaultToEN: !0\r\n        })\r\n    }\r\n    redefaultToSystem(e = {}) {\r\n        return this.clone({\r\n            ...e,\r\n            defaultToEN: !1\r\n        })\r\n    }\r\n    months(r, n = !1, e = !0) {\r\n        return We(this, r, e, ae, () => {\r\n            const t = n ? {\r\n                    month: r,\r\n                    day: \"numeric\"\r\n                } : {\r\n                    month: r\r\n                },\r\n                e = n ? \"format\" : \"standalone\";\r\n            return this.monthsCache[e][r] || (this.monthsCache[e][r] = function (t) {\r\n                const r = [];\r\n                for (let e = 1; e <= 12; e++) {\r\n                    var n = Wr.utc(2016, e, 1);\r\n                    r.push(t(n))\r\n                }\r\n                return r\r\n            }(e => this.extract(e, t, \"month\"))), this.monthsCache[e][r]\r\n        })\r\n    }\r\n    weekdays(r, n = !1, e = !0) {\r\n        return We(this, r, e, ce, () => {\r\n            const t = n ? {\r\n                    weekday: r,\r\n                    year: \"numeric\",\r\n                    month: \"long\",\r\n                    day: \"numeric\"\r\n                } : {\r\n                    weekday: r\r\n                },\r\n                e = n ? \"format\" : \"standalone\";\r\n            return this.weekdaysCache[e][r] || (this.weekdaysCache[e][r] = function (t) {\r\n                const r = [];\r\n                for (let e = 1; e <= 7; e++) {\r\n                    var n = Wr.utc(2016, 11, 13 + e);\r\n                    r.push(t(n))\r\n                }\r\n                return r\r\n            }(e => this.extract(e, t, \"weekday\"))), this.weekdaysCache[e][r]\r\n        })\r\n    }\r\n    meridiems(e = !0) {\r\n        return We(this, void 0, e, () => he, () => {\r\n            if (!this.meridiemCache) {\r\n                const t = {\r\n                    hour: \"numeric\",\r\n                    hourCycle: \"h12\"\r\n                };\r\n                this.meridiemCache = [Wr.utc(2016, 11, 13, 9), Wr.utc(2016, 11, 13, 19)].map(e => this.extract(e, t, \"dayperiod\"))\r\n            }\r\n            return this.meridiemCache\r\n        })\r\n    }\r\n    eras(e, t = !0) {\r\n        return We(this, e, t, ye, () => {\r\n            const t = {\r\n                era: e\r\n            };\r\n            return this.eraCache[e] || (this.eraCache[e] = [Wr.utc(-40, 1, 1), Wr.utc(2017, 1, 1)].map(e => this.extract(e, t, \"era\"))), this.eraCache[e]\r\n        })\r\n    }\r\n    extract(e, t, r) {\r\n        const n = this.dtFormatter(e, t),\r\n            s = n.formatToParts(),\r\n            i = s.find(e => e.type.toLowerCase() === r);\r\n        return i ? i.value : null\r\n    }\r\n    numberFormatter(e = {}) {\r\n        return new Re(this.intl, e.forceSimple || this.fastNumbers, e)\r\n    }\r\n    dtFormatter(e, t = {}) {\r\n        return new Pe(e, this.intl, t)\r\n    }\r\n    relFormatter(e = {}) {\r\n        return new Je(this.intl, this.isEnglish(), e)\r\n    }\r\n    isEnglish() {\r\n        return \"en\" === this.locale || \"en-us\" === this.locale.toLowerCase() || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith(\"en-us\")\r\n    }\r\n    equals(e) {\r\n        return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar\r\n    }\r\n}\r\n\r\nfunction Ge(...e) {\r\n    e = e.reduce((e, t) => e + t.source, \"\");\r\n    return RegExp(`^${e}$`)\r\n}\r\n\r\nfunction Be(...e) {\r\n    return i => e.reduce(([e, t, r], n) => {\r\n        var [s, n, r] = n(i, r);\r\n        return [{\r\n            ...e,\r\n            ...s\r\n        }, t || n, r]\r\n    }, [{}, null, 1]).slice(0, 2)\r\n}\r\n\r\nfunction Qe(e, ...t) {\r\n    if (null == e) return [null, null];\r\n    for (var [r, n] of t) {\r\n        r = r.exec(e);\r\n        if (r) return n(r)\r\n    }\r\n    return [null, null]\r\n}\r\n\r\nfunction Ke(...s) {\r\n    return (e, t) => {\r\n        const r = {};\r\n        let n;\r\n        for (n = 0; n < s.length; n++) r[s[n]] = _(e[t + n]);\r\n        return [r, null, t + n]\r\n    }\r\n}\r\nvar Xe = /(?:(Z)|([+-]\\d\\d)(?::?(\\d\\d))?)/,\r\n    et = /(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:[.,](\\d{1,30}))?)?)?/,\r\n    tt = RegExp(`${et.source}${Xe.source}?`),\r\n    u = RegExp(`(?:T${tt.source})?`),\r\n    t = Ke(\"weekYear\", \"weekNumber\", \"weekDay\"),\r\n    l = Ke(\"year\", \"ordinal\"),\r\n    Xe = RegExp(`${et.source} ?(?:${Xe.source}|(${re.source}))?`),\r\n    re = RegExp(`(?: ${Xe.source})?`);\r\n\r\nfunction rt(e, t, r) {\r\n    t = e[t];\r\n    return $(t) ? r : _(t)\r\n}\r\n\r\nfunction nt(e, t) {\r\n    return [{\r\n        year: rt(e, t),\r\n        month: rt(e, t + 1, 1),\r\n        day: rt(e, t + 2, 1)\r\n    }, null, t + 3]\r\n}\r\n\r\nfunction st(e, t) {\r\n    return [{\r\n        hours: rt(e, t, 0),\r\n        minutes: rt(e, t + 1, 0),\r\n        seconds: rt(e, t + 2, 0),\r\n        milliseconds: U(e[t + 3])\r\n    }, null, t + 4]\r\n}\r\n\r\nfunction it(e, t) {\r\n    var r = !e[t] && !e[t + 1],\r\n        e = Q(e[t + 1], e[t + 2]);\r\n    return [{}, r ? null : Ve.instance(e), t + 3]\r\n}\r\n\r\nfunction at(e, t) {\r\n    return [{}, e[t] ? De.create(e[t]) : null, t + 1]\r\n}\r\nconst ot = RegExp(`^T?${et.source}$`),\r\n    ut = /^-?P(?:(?:(-?\\d{1,9})Y)?(?:(-?\\d{1,9})M)?(?:(-?\\d{1,9})W)?(?:(-?\\d{1,9})D)?(?:T(?:(-?\\d{1,9})H)?(?:(-?\\d{1,9})M)?(?:(-?\\d{1,20})(?:[.,](-?\\d{1,9}))?S)?)?)$/;\r\n\r\nfunction lt(e) {\r\n    var [t, r, n, s, i, a, o, u, l] = e;\r\n    const c = \"-\" === t[0];\r\n    e = u && \"-\" === u[0], t = (e, t = !1) => void 0 !== e && (t || e && c) ? -e : e;\r\n    return [{\r\n        years: t(_(r)),\r\n        months: t(_(n)),\r\n        weeks: t(_(s)),\r\n        days: t(_(i)),\r\n        hours: t(_(a)),\r\n        minutes: t(_(o)),\r\n        seconds: t(_(u), \"-0\" === u),\r\n        milliseconds: t(U(l), e)\r\n    }]\r\n}\r\nconst ct = {\r\n    GMT: 0,\r\n    EDT: -240,\r\n    EST: -300,\r\n    CDT: -300,\r\n    CST: -360,\r\n    MDT: -360,\r\n    MST: -420,\r\n    PDT: -420,\r\n    PST: -480\r\n};\r\n\r\nfunction ht(e, t, r, n, s, i, a) {\r\n    const o = {\r\n        year: 2 === t.length ? G(_(t)) : _(t),\r\n        month: se.indexOf(r) + 1,\r\n        day: _(n),\r\n        hour: _(s),\r\n        minute: _(i)\r\n    };\r\n    return a && (o.second = _(a)), e && (o.weekday = 3 < e.length ? oe.indexOf(e) + 1 : ue.indexOf(e) + 1), o\r\n}\r\nconst dt = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\\d\\d)(\\d\\d)))$/;\r\n\r\nfunction mt(e) {\r\n    var [, t, r, n, s, i, a, o, u, l, c, e] = e, o = ht(t, s, n, r, i, a, o);\r\n    let h;\r\n    return h = u ? ct[u] : l ? 0 : Q(c, e), [o, new Ve(h)]\r\n}\r\nconst ft = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d\\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\r\n    yt = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\\d\\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\r\n    gt = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \\d|\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) (\\d{4})$/;\r\n\r\nfunction wt(e) {\r\n    var [, t, r, n, s, i, a, e] = e;\r\n    return [ht(t, s, n, r, i, a, e), Ve.utcInstance]\r\n}\r\n\r\nfunction pt(e) {\r\n    var [, t, r, n, s, i, a, e] = e;\r\n    return [ht(t, e, r, n, s, i, a), Ve.utcInstance]\r\n}\r\nconst vt = Ge(/([+-]\\d{6}|\\d{4})(?:-?(\\d\\d)(?:-?(\\d\\d))?)?/, u),\r\n    Tt = Ge(/(\\d{4})-?W(\\d\\d)(?:-?(\\d))?/, u),\r\n    St = Ge(/(\\d{4})-?(\\d{3})/, u),\r\n    Ot = Ge(tt),\r\n    bt = Be(nt, st, it),\r\n    Mt = Be(t, st, it),\r\n    kt = Be(l, st, it),\r\n    Nt = Be(st, it);\r\nconst Dt = Be(st);\r\nconst Et = Ge(/(\\d{4})-(\\d\\d)-(\\d\\d)/, re),\r\n    Vt = Ge(Xe),\r\n    It = Be(nt, st, it, at),\r\n    xt = Be(st, it, at);\r\nconst Ct = {\r\n        weeks: {\r\n            days: 7,\r\n            hours: 168,\r\n            minutes: 10080,\r\n            seconds: 604800,\r\n            milliseconds: 6048e5\r\n        },\r\n        days: {\r\n            hours: 24,\r\n            minutes: 1440,\r\n            seconds: 86400,\r\n            milliseconds: 864e5\r\n        },\r\n        hours: {\r\n            minutes: 60,\r\n            seconds: 3600,\r\n            milliseconds: 36e5\r\n        },\r\n        minutes: {\r\n            seconds: 60,\r\n            milliseconds: 6e4\r\n        },\r\n        seconds: {\r\n            milliseconds: 1e3\r\n        }\r\n    },\r\n    $t = {\r\n        years: {\r\n            quarters: 4,\r\n            months: 12,\r\n            weeks: 52,\r\n            days: 365,\r\n            hours: 8760,\r\n            minutes: 525600,\r\n            seconds: 31536e3,\r\n            milliseconds: 31536e6\r\n        },\r\n        quarters: {\r\n            months: 3,\r\n            weeks: 13,\r\n            days: 91,\r\n            hours: 2184,\r\n            minutes: 131040,\r\n            seconds: 7862400,\r\n            milliseconds: 78624e5\r\n        },\r\n        months: {\r\n            weeks: 4,\r\n            days: 30,\r\n            hours: 720,\r\n            minutes: 43200,\r\n            seconds: 2592e3,\r\n            milliseconds: 2592e6\r\n        },\r\n        ...Ct\r\n    },\r\n    Zt = 365.2425,\r\n    Ft = 30.436875,\r\n    Lt = {\r\n        years: {\r\n            quarters: 4,\r\n            months: 12,\r\n            weeks: Zt / 7,\r\n            days: Zt,\r\n            hours: 24 * Zt,\r\n            minutes: 525949.2,\r\n            seconds: 525949.2 * 60,\r\n            milliseconds: 525949.2 * 60 * 1e3\r\n        },\r\n        quarters: {\r\n            months: 3,\r\n            weeks: Zt / 28,\r\n            days: Zt / 4,\r\n            hours: 24 * Zt / 4,\r\n            minutes: 131487.3,\r\n            seconds: 525949.2 * 60 / 4,\r\n            milliseconds: 7889237999.999999\r\n        },\r\n        months: {\r\n            weeks: Ft / 7,\r\n            days: Ft,\r\n            hours: 24 * Ft,\r\n            minutes: 43829.1,\r\n            seconds: 2629746,\r\n            milliseconds: 2629746e3\r\n        },\r\n        ...Ct\r\n    },\r\n    zt = [\"years\", \"quarters\", \"months\", \"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\", \"milliseconds\"],\r\n    qt = zt.slice(0).reverse();\r\n\r\nfunction At(e, t, r = !1) {\r\n    e = {\r\n        values: r ? t.values : {\r\n            ...e.values,\r\n            ...t.values || {}\r\n        },\r\n        loc: e.loc.clone(t.loc),\r\n        conversionAccuracy: t.conversionAccuracy || e.conversionAccuracy\r\n    };\r\n    return new _t(e)\r\n}\r\n\r\nfunction jt(e, t, r, n, s) {\r\n    var i = e[s][r],\r\n        a = t[r] / i,\r\n        a = !(Math.sign(a) === Math.sign(n[s])) && 0 !== n[s] && Math.abs(a) <= 1 ? (e = a) < 0 ? Math.floor(e) : Math.ceil(e) : Math.trunc(a);\r\n    n[s] += a, t[r] -= a * i\r\n}\r\nclass _t {\r\n    constructor(e) {\r\n        var t = \"longterm\" === e.conversionAccuracy || !1;\r\n        this.values = e.values, this.loc = e.loc || Ye.create(), this.conversionAccuracy = t ? \"longterm\" : \"casual\", this.invalid = e.invalid || null, this.matrix = t ? Lt : $t, this.isLuxonDuration = !0\r\n    }\r\n    static fromMillis(e, t) {\r\n        return _t.fromObject({\r\n            milliseconds: e\r\n        }, t)\r\n    }\r\n    static fromObject(e, t = {}) {\r\n        if (null == e || \"object\" != typeof e) throw new a(`Duration.fromObject: argument expected to be an object, got ${null===e?\"null\":typeof e}`);\r\n        return new _t({\r\n            values: X(e, _t.normalizeUnit),\r\n            loc: Ye.fromObject(t),\r\n            conversionAccuracy: t.conversionAccuracy\r\n        })\r\n    }\r\n    static fromISO(e, t) {\r\n        var [r] = Qe(e, [ut, lt]);\r\n        return r ? _t.fromObject(r, t) : _t.invalid(\"unparsable\", `the input \"${e}\" can't be parsed as ISO 8601`)\r\n    }\r\n    static fromISOTime(e, t) {\r\n        var [r] = Qe(e, [ot, Dt]);\r\n        return r ? _t.fromObject(r, t) : _t.invalid(\"unparsable\", `the input \"${e}\" can't be parsed as ISO 8601`)\r\n    }\r\n    static invalid(e, t = null) {\r\n        if (!e) throw new a(\"need to specify a reason the Duration is invalid\");\r\n        t = e instanceof ve ? e : new ve(e, t);\r\n        if (qe.throwOnInvalid) throw new s(t);\r\n        return new _t({\r\n            invalid: t\r\n        })\r\n    }\r\n    static normalizeUnit(e) {\r\n        var t = {\r\n            year: \"years\",\r\n            years: \"years\",\r\n            quarter: \"quarters\",\r\n            quarters: \"quarters\",\r\n            month: \"months\",\r\n            months: \"months\",\r\n            week: \"weeks\",\r\n            weeks: \"weeks\",\r\n            day: \"days\",\r\n            days: \"days\",\r\n            hour: \"hours\",\r\n            hours: \"hours\",\r\n            minute: \"minutes\",\r\n            minutes: \"minutes\",\r\n            second: \"seconds\",\r\n            seconds: \"seconds\",\r\n            millisecond: \"milliseconds\",\r\n            milliseconds: \"milliseconds\"\r\n        } [e && e.toLowerCase()];\r\n        if (!t) throw new i(e);\r\n        return t\r\n    }\r\n    static isDuration(e) {\r\n        return e && e.isLuxonDuration || !1\r\n    }\r\n    get locale() {\r\n        return this.isValid ? this.loc.locale : null\r\n    }\r\n    get numberingSystem() {\r\n        return this.isValid ? this.loc.numberingSystem : null\r\n    }\r\n    toFormat(e, t = {}) {\r\n        t = {\r\n            ...t,\r\n            floor: !1 !== t.round && !1 !== t.floor\r\n        };\r\n        return this.isValid ? pe.create(this.loc, t).formatDurationFromString(this, e) : \"Invalid Duration\"\r\n    }\r\n    toObject() {\r\n        return this.isValid ? {\r\n            ...this.values\r\n        } : {}\r\n    }\r\n    toISO() {\r\n        if (!this.isValid) return null;\r\n        let e = \"P\";\r\n        return 0 !== this.years && (e += this.years + \"Y\"), 0 === this.months && 0 === this.quarters || (e += this.months + 3 * this.quarters + \"M\"), 0 !== this.weeks && (e += this.weeks + \"W\"), 0 !== this.days && (e += this.days + \"D\"), 0 === this.hours && 0 === this.minutes && 0 === this.seconds && 0 === this.milliseconds || (e += \"T\"), 0 !== this.hours && (e += this.hours + \"H\"), 0 !== this.minutes && (e += this.minutes + \"M\"), 0 === this.seconds && 0 === this.milliseconds || (e += H(this.seconds + this.milliseconds / 1e3, 3) + \"S\"), \"P\" === e && (e += \"T0S\"), e\r\n    }\r\n    toISOTime(e = {}) {\r\n        if (!this.isValid) return null;\r\n        var t = this.toMillis();\r\n        if (t < 0 || 864e5 <= t) return null;\r\n        e = {\r\n            suppressMilliseconds: !1,\r\n            suppressSeconds: !1,\r\n            includePrefix: !1,\r\n            format: \"extended\",\r\n            ...e\r\n        };\r\n        const r = this.shiftTo(\"hours\", \"minutes\", \"seconds\", \"milliseconds\");\r\n        let n = \"basic\" === e.format ? \"hhmm\" : \"hh:mm\";\r\n        e.suppressSeconds && 0 === r.seconds && 0 === r.milliseconds || (n += \"basic\" === e.format ? \"ss\" : \":ss\", e.suppressMilliseconds && 0 === r.milliseconds || (n += \".SSS\"));\r\n        let s = r.toFormat(n);\r\n        return e.includePrefix && (s = \"T\" + s), s\r\n    }\r\n    toJSON() {\r\n        return this.toISO()\r\n    }\r\n    toString() {\r\n        return this.toISO()\r\n    }\r\n    toMillis() {\r\n        return this.as(\"milliseconds\")\r\n    }\r\n    valueOf() {\r\n        return this.toMillis()\r\n    }\r\n    plus(e) {\r\n        if (!this.isValid) return this;\r\n        const t = Ut(e),\r\n            r = {};\r\n        for (const n of zt)(q(t.values, n) || q(this.values, n)) && (r[n] = t.get(n) + this.get(n));\r\n        return At(this, {\r\n            values: r\r\n        }, !0)\r\n    }\r\n    minus(e) {\r\n        if (!this.isValid) return this;\r\n        const t = Ut(e);\r\n        return this.plus(t.negate())\r\n    }\r\n    mapUnits(e) {\r\n        if (!this.isValid) return this;\r\n        const t = {};\r\n        for (const r of Object.keys(this.values)) t[r] = K(e(this.values[r], r));\r\n        return At(this, {\r\n            values: t\r\n        }, !0)\r\n    }\r\n    get(e) {\r\n        return this[_t.normalizeUnit(e)]\r\n    }\r\n    set(e) {\r\n        return this.isValid ? At(this, {\r\n            values: {\r\n                ...this.values,\r\n                ...X(e, _t.normalizeUnit)\r\n            }\r\n        }) : this\r\n    }\r\n    reconfigure({\r\n        locale: e,\r\n        numberingSystem: t,\r\n        conversionAccuracy: r\r\n    } = {}) {\r\n        const n = this.loc.clone({\r\n                locale: e,\r\n                numberingSystem: t\r\n            }),\r\n            s = {\r\n                loc: n\r\n            };\r\n        return r && (s.conversionAccuracy = r), At(this, s)\r\n    }\r\n    as(e) {\r\n        return this.isValid ? this.shiftTo(e).get(e) : NaN\r\n    }\r\n    normalize() {\r\n        if (!this.isValid) return this;\r\n        var r, n, e = this.toObject();\r\n        return r = this.matrix, n = e, qt.reduce((e, t) => $(n[t]) ? e : (e && jt(r, n, e, n, t), t), null), At(this, {\r\n            values: e\r\n        }, !0)\r\n    }\r\n    shiftTo(...e) {\r\n        if (!this.isValid) return this;\r\n        if (0 === e.length) return this;\r\n        e = e.map(e => _t.normalizeUnit(e));\r\n        const t = {},\r\n            r = {},\r\n            n = this.toObject();\r\n        let s;\r\n        for (const a of zt)\r\n            if (0 <= e.indexOf(a)) {\r\n                s = a;\r\n                let e = 0;\r\n                for (const o in r) e += this.matrix[o][a] * r[o], r[o] = 0;\r\n                Z(n[a]) && (e += n[a]);\r\n                var i = Math.trunc(e);\r\n                t[a] = i, r[a] = e - i;\r\n                for (const u in n) zt.indexOf(u) > zt.indexOf(a) && jt(this.matrix, n, u, t, a)\r\n            } else Z(n[a]) && (r[a] = n[a]);\r\n        for (const l in r) 0 !== r[l] && (t[s] += l === s ? r[l] : r[l] / this.matrix[s][l]);\r\n        return At(this, {\r\n            values: t\r\n        }, !0).normalize()\r\n    }\r\n    negate() {\r\n        if (!this.isValid) return this;\r\n        const e = {};\r\n        for (const t of Object.keys(this.values)) e[t] = -this.values[t];\r\n        return At(this, {\r\n            values: e\r\n        }, !0)\r\n    }\r\n    get years() {\r\n        return this.isValid ? this.values.years || 0 : NaN\r\n    }\r\n    get quarters() {\r\n        return this.isValid ? this.values.quarters || 0 : NaN\r\n    }\r\n    get months() {\r\n        return this.isValid ? this.values.months || 0 : NaN\r\n    }\r\n    get weeks() {\r\n        return this.isValid ? this.values.weeks || 0 : NaN\r\n    }\r\n    get days() {\r\n        return this.isValid ? this.values.days || 0 : NaN\r\n    }\r\n    get hours() {\r\n        return this.isValid ? this.values.hours || 0 : NaN\r\n    }\r\n    get minutes() {\r\n        return this.isValid ? this.values.minutes || 0 : NaN\r\n    }\r\n    get seconds() {\r\n        return this.isValid ? this.values.seconds || 0 : NaN\r\n    }\r\n    get milliseconds() {\r\n        return this.isValid ? this.values.milliseconds || 0 : NaN\r\n    }\r\n    get isValid() {\r\n        return null === this.invalid\r\n    }\r\n    get invalidReason() {\r\n        return this.invalid ? this.invalid.reason : null\r\n    }\r\n    get invalidExplanation() {\r\n        return this.invalid ? this.invalid.explanation : null\r\n    }\r\n    equals(e) {\r\n        if (!this.isValid || !e.isValid) return !1;\r\n        if (!this.loc.equals(e.loc)) return !1;\r\n        for (const n of zt)\r\n            if (t = this.values[n], r = e.values[n], !(void 0 === t || 0 === t ? void 0 === r || 0 === r : t === r)) return !1;\r\n        var t, r;\r\n        return !0\r\n    }\r\n}\r\n\r\nfunction Ut(e) {\r\n    if (Z(e)) return _t.fromMillis(e);\r\n    if (_t.isDuration(e)) return e;\r\n    if (\"object\" == typeof e) return _t.fromObject(e);\r\n    throw new a(`Unknown duration argument ${e} of type ${typeof e}`)\r\n}\r\nconst Ht = \"Invalid Interval\";\r\nclass Wt {\r\n    constructor(e) {\r\n        this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0\r\n    }\r\n    static invalid(e, t = null) {\r\n        if (!e) throw new a(\"need to specify a reason the Interval is invalid\");\r\n        t = e instanceof ve ? e : new ve(e, t);\r\n        if (qe.throwOnInvalid) throw new n(t);\r\n        return new Wt({\r\n            invalid: t\r\n        })\r\n    }\r\n    static fromDateTimes(e, t) {\r\n        var r = Rr(e),\r\n            n = Rr(t),\r\n            e = (e = n, (t = r) && t.isValid ? e && e.isValid ? e < t ? Wt.invalid(\"end before start\", `The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`) : null : Wt.invalid(\"missing or invalid end\") : Wt.invalid(\"missing or invalid start\"));\r\n        return null == e ? new Wt({\r\n            start: r,\r\n            end: n\r\n        }) : e\r\n    }\r\n    static after(e, t) {\r\n        const r = Ut(t),\r\n            n = Rr(e);\r\n        return Wt.fromDateTimes(n, n.plus(r))\r\n    }\r\n    static before(e, t) {\r\n        const r = Ut(t),\r\n            n = Rr(e);\r\n        return Wt.fromDateTimes(n.minus(r), n)\r\n    }\r\n    static fromISO(e, s) {\r\n        var [i, a] = (e || \"\").split(\"/\", 2);\r\n        if (i && a) {\r\n            let e, t;\r\n            try {\r\n                e = Wr.fromISO(i, s), t = e.isValid\r\n            } catch (a) {\r\n                t = !1\r\n            }\r\n            let r, n;\r\n            try {\r\n                r = Wr.fromISO(a, s), n = r.isValid\r\n            } catch (a) {\r\n                n = !1\r\n            }\r\n            if (t && n) return Wt.fromDateTimes(e, r);\r\n            if (t) {\r\n                var o = _t.fromISO(a, s);\r\n                if (o.isValid) return Wt.after(e, o)\r\n            } else if (n) {\r\n                s = _t.fromISO(i, s);\r\n                if (s.isValid) return Wt.before(r, s)\r\n            }\r\n        }\r\n        return Wt.invalid(\"unparsable\", `the input \"${e}\" can't be parsed as ISO 8601`)\r\n    }\r\n    static isInterval(e) {\r\n        return e && e.isLuxonInterval || !1\r\n    }\r\n    get start() {\r\n        return this.isValid ? this.s : null\r\n    }\r\n    get end() {\r\n        return this.isValid ? this.e : null\r\n    }\r\n    get isValid() {\r\n        return null === this.invalidReason\r\n    }\r\n    get invalidReason() {\r\n        return this.invalid ? this.invalid.reason : null\r\n    }\r\n    get invalidExplanation() {\r\n        return this.invalid ? this.invalid.explanation : null\r\n    }\r\n    length(e = \"milliseconds\") {\r\n        return this.isValid ? this.toDuration(e).get(e) : NaN\r\n    }\r\n    count(e = \"milliseconds\") {\r\n        if (!this.isValid) return NaN;\r\n        const t = this.start.startOf(e),\r\n            r = this.end.startOf(e);\r\n        return Math.floor(r.diff(t, e).get(e)) + 1\r\n    }\r\n    hasSame(e) {\r\n        return !!this.isValid && (this.isEmpty() || this.e.minus(1).hasSame(this.s, e))\r\n    }\r\n    isEmpty() {\r\n        return this.s.valueOf() === this.e.valueOf()\r\n    }\r\n    isAfter(e) {\r\n        return !!this.isValid && this.s > e\r\n    }\r\n    isBefore(e) {\r\n        return !!this.isValid && this.e <= e\r\n    }\r\n    contains(e) {\r\n        return !!this.isValid && (this.s <= e && this.e > e)\r\n    }\r\n    set({\r\n        start: e,\r\n        end: t\r\n    } = {}) {\r\n        return this.isValid ? Wt.fromDateTimes(e || this.s, t || this.e) : this\r\n    }\r\n    splitAt(...e) {\r\n        if (!this.isValid) return [];\r\n        const t = e.map(Rr).filter(e => this.contains(e)).sort(),\r\n            r = [];\r\n        let {\r\n            s: n\r\n        } = this, s = 0;\r\n        for (; n < this.e;) {\r\n            var i = t[s] || this.e,\r\n                i = +i > +this.e ? this.e : i;\r\n            r.push(Wt.fromDateTimes(n, i)), n = i, s += 1\r\n        }\r\n        return r\r\n    }\r\n    splitBy(e) {\r\n        const t = Ut(e);\r\n        if (!this.isValid || !t.isValid || 0 === t.as(\"milliseconds\")) return [];\r\n        let {\r\n            s: r\r\n        } = this, n = 1, s;\r\n        const i = [];\r\n        for (; r < this.e;) {\r\n            var a = this.start.plus(t.mapUnits(e => e * n));\r\n            s = +a > +this.e ? this.e : a, i.push(Wt.fromDateTimes(r, s)), r = s, n += 1\r\n        }\r\n        return i\r\n    }\r\n    divideEqually(e) {\r\n        return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : []\r\n    }\r\n    overlaps(e) {\r\n        return this.e > e.s && this.s < e.e\r\n    }\r\n    abutsStart(e) {\r\n        return !!this.isValid && +this.e == +e.s\r\n    }\r\n    abutsEnd(e) {\r\n        return !!this.isValid && +e.e == +this.s\r\n    }\r\n    engulfs(e) {\r\n        return !!this.isValid && (this.s <= e.s && this.e >= e.e)\r\n    }\r\n    equals(e) {\r\n        return !(!this.isValid || !e.isValid) && (this.s.equals(e.s) && this.e.equals(e.e))\r\n    }\r\n    intersection(e) {\r\n        if (!this.isValid) return this;\r\n        var t = (this.s > e.s ? this : e).s,\r\n            e = (this.e < e.e ? this : e).e;\r\n        return e <= t ? null : Wt.fromDateTimes(t, e)\r\n    }\r\n    union(e) {\r\n        if (!this.isValid) return this;\r\n        var t = (this.s < e.s ? this : e).s,\r\n            e = (this.e > e.e ? this : e).e;\r\n        return Wt.fromDateTimes(t, e)\r\n    }\r\n    static merge(e) {\r\n        const [t, r] = e.sort((e, t) => e.s - t.s).reduce(([e, t], r) => t ? t.overlaps(r) || t.abutsStart(r) ? [e, t.union(r)] : [e.concat([t]), r] : [e, r], [\r\n            [], null\r\n        ]);\r\n        return r && t.push(r), t\r\n    }\r\n    static xor(e) {\r\n        let t = null,\r\n            r = 0;\r\n        const n = [],\r\n            s = e.map(e => [{\r\n                time: e.s,\r\n                type: \"s\"\r\n            }, {\r\n                time: e.e,\r\n                type: \"e\"\r\n            }]),\r\n            i = Array.prototype.concat(...s),\r\n            a = i.sort((e, t) => e.time - t.time);\r\n        for (const o of a) r += \"s\" === o.type ? 1 : -1, t = 1 === r ? o.time : (t && +t != +o.time && n.push(Wt.fromDateTimes(t, o.time)), null);\r\n        return Wt.merge(n)\r\n    }\r\n    difference(...e) {\r\n        return Wt.xor([this].concat(e)).map(e => this.intersection(e)).filter(e => e && !e.isEmpty())\r\n    }\r\n    toString() {\r\n        return this.isValid ? `[${this.s.toISO()}  ${this.e.toISO()})` : Ht\r\n    }\r\n    toISO(e) {\r\n        return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : Ht\r\n    }\r\n    toISODate() {\r\n        return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : Ht\r\n    }\r\n    toISOTime(e) {\r\n        return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : Ht\r\n    }\r\n    toFormat(e, {\r\n        separator: t = \"  \"\r\n    } = {}) {\r\n        return this.isValid ? `${this.s.toFormat(e)}${t}${this.e.toFormat(e)}` : Ht\r\n    }\r\n    toDuration(e, t) {\r\n        return this.isValid ? this.e.diff(this.s, e, t) : _t.invalid(this.invalidReason)\r\n    }\r\n    mapEndpoints(e) {\r\n        return Wt.fromDateTimes(e(this.s), e(this.e))\r\n    }\r\n}\r\nclass Rt {\r\n    static hasDST(e = qe.defaultZone) {\r\n        const t = Wr.now().setZone(e).set({\r\n            month: 12\r\n        });\r\n        return !e.isUniversal && t.offset !== t.set({\r\n            month: 6\r\n        }).offset\r\n    }\r\n    static isValidIANAZone(e) {\r\n        return De.isValidSpecifier(e) && De.isValidZone(e)\r\n    }\r\n    static normalizeZone(e) {\r\n        return xe(e, qe.defaultZone)\r\n    }\r\n    static months(e = \"long\", {\r\n        locale: t = null,\r\n        numberingSystem: r = null,\r\n        locObj: n = null,\r\n        outputCalendar: s = \"gregory\"\r\n    } = {}) {\r\n        return (n || Ye.create(t, r, s)).months(e)\r\n    }\r\n    static monthsFormat(e = \"long\", {\r\n        locale: t = null,\r\n        numberingSystem: r = null,\r\n        locObj: n = null,\r\n        outputCalendar: s = \"gregory\"\r\n    } = {}) {\r\n        return (n || Ye.create(t, r, s)).months(e, !0)\r\n    }\r\n    static weekdays(e = \"long\", {\r\n        locale: t = null,\r\n        numberingSystem: r = null,\r\n        locObj: n = null\r\n    } = {}) {\r\n        return (n || Ye.create(t, r, null)).weekdays(e)\r\n    }\r\n    static weekdaysFormat(e = \"long\", {\r\n        locale: t = null,\r\n        numberingSystem: r = null,\r\n        locObj: n = null\r\n    } = {}) {\r\n        return (n || Ye.create(t, r, null)).weekdays(e, !0)\r\n    }\r\n    static meridiems({\r\n        locale: e = null\r\n    } = {}) {\r\n        return Ye.create(e).meridiems()\r\n    }\r\n    static eras(e = \"short\", {\r\n        locale: t = null\r\n    } = {}) {\r\n        return Ye.create(t, null, \"gregory\").eras(e)\r\n    }\r\n    static features() {\r\n        return {\r\n            relative: L()\r\n        }\r\n    }\r\n}\r\n\r\nfunction Pt(e, t) {\r\n    var r = e => e.toUTC(0, {\r\n            keepLocalTime: !0\r\n        }).startOf(\"day\").valueOf(),\r\n        e = r(t) - r(e);\r\n    return Math.floor(_t.fromMillis(e).as(\"days\"))\r\n}\r\n\r\nfunction Jt(e, t, r, n) {\r\n    let [s, i, a, o] = function (t, r, e) {\r\n        var n, s;\r\n        const i = {};\r\n        let a, o;\r\n        for ([n, s] of [\r\n                [\"years\", (e, t) => t.year - e.year],\r\n                [\"quarters\", (e, t) => t.quarter - e.quarter],\r\n                [\"months\", (e, t) => t.month - e.month + 12 * (t.year - e.year)],\r\n                [\"weeks\", (e, t) => {\r\n                    t = Pt(e, t);\r\n                    return (t - t % 7) / 7\r\n                }],\r\n                [\"days\", Pt]\r\n            ])\r\n            if (0 <= e.indexOf(n)) {\r\n                a = n;\r\n                let e = s(t, r);\r\n                o = t.plus({\r\n                    [n]: e\r\n                }), o > r ? (t = t.plus({\r\n                    [n]: e - 1\r\n                }), --e) : t = o, i[n] = e\r\n            } return [t, i, o, a]\r\n    }(e, t, r);\r\n    e = t - s, r = r.filter(e => 0 <= [\"hours\", \"minutes\", \"seconds\", \"milliseconds\"].indexOf(e));\r\n    0 === r.length && (a < t && (a = s.plus({\r\n        [o]: 1\r\n    })), a !== s && (i[o] = (i[o] || 0) + e / (a - s)));\r\n    t = _t.fromObject(i, n);\r\n    return 0 < r.length ? _t.fromMillis(e, n).shiftTo(...r).plus(t) : t\r\n}\r\nconst Yt = {\r\n        arab: \"[-]\",\r\n        arabext: \"[-]\",\r\n        bali: \"[-]\",\r\n        beng: \"[-]\",\r\n        deva: \"[-]\",\r\n        fullwide: \"[-]\",\r\n        gujr: \"[-]\",\r\n        hanidec: \"[|||||||||]\",\r\n        khmr: \"[-]\",\r\n        knda: \"[-]\",\r\n        laoo: \"[-]\",\r\n        limb: \"[-]\",\r\n        mlym: \"[-]\",\r\n        mong: \"[-]\",\r\n        mymr: \"[-]\",\r\n        orya: \"[-]\",\r\n        tamldec: \"[-]\",\r\n        telu: \"[-]\",\r\n        thai: \"[-]\",\r\n        tibt: \"[-]\",\r\n        latn: \"\\\\d\"\r\n    },\r\n    Gt = {\r\n        arab: [1632, 1641],\r\n        arabext: [1776, 1785],\r\n        bali: [6992, 7001],\r\n        beng: [2534, 2543],\r\n        deva: [2406, 2415],\r\n        fullwide: [65296, 65303],\r\n        gujr: [2790, 2799],\r\n        khmr: [6112, 6121],\r\n        knda: [3302, 3311],\r\n        laoo: [3792, 3801],\r\n        limb: [6470, 6479],\r\n        mlym: [3430, 3439],\r\n        mong: [6160, 6169],\r\n        mymr: [4160, 4169],\r\n        orya: [2918, 2927],\r\n        tamldec: [3046, 3055],\r\n        telu: [3174, 3183],\r\n        thai: [3664, 3673],\r\n        tibt: [3872, 3881]\r\n    },\r\n    Bt = Yt.hanidec.replace(/[\\[|\\]]/g, \"\").split(\"\");\r\n\r\nfunction Qt({\r\n    numberingSystem: e\r\n}, t = \"\") {\r\n    return new RegExp(`${Yt[e||\"latn\"]}${t}`)\r\n}\r\nconst Kt = \"missing Intl.DateTimeFormat.formatToParts support\";\r\n\r\nfunction Xt(e, t = e => e) {\r\n    return {\r\n        regex: e,\r\n        deser: ([e]) => t(function (t) {\r\n            let r = parseInt(t, 10);\r\n            if (isNaN(r)) {\r\n                r = \"\";\r\n                for (let e = 0; e < t.length; e++) {\r\n                    var n = t.charCodeAt(e);\r\n                    if (-1 !== t[e].search(Yt.hanidec)) r += Bt.indexOf(t[e]);\r\n                    else\r\n                        for (const a in Gt) {\r\n                            var [s, i] = Gt[a];\r\n                            s <= n && n <= i && (r += n - s)\r\n                        }\r\n                }\r\n                return parseInt(r, 10)\r\n            }\r\n            return r\r\n        }(e))\r\n    }\r\n}\r\nconst er = `( |${String.fromCharCode(160)})`,\r\n    tr = new RegExp(er, \"g\");\r\n\r\nfunction rr(e) {\r\n    return e.replace(/\\./g, \"\\\\.?\").replace(tr, er)\r\n}\r\n\r\nfunction nr(e) {\r\n    return e.replace(/\\./g, \"\").replace(tr, \" \").toLowerCase()\r\n}\r\n\r\nfunction sr(e, r) {\r\n    return null === e ? null : {\r\n        regex: RegExp(e.map(rr).join(\"|\")),\r\n        deser: ([t]) => e.findIndex(e => nr(t) === nr(e)) + r\r\n    }\r\n}\r\n\r\nfunction ir(e, t) {\r\n    return {\r\n        regex: e,\r\n        deser: ([, e, t]) => Q(e, t),\r\n        groups: t\r\n    }\r\n}\r\n\r\nfunction ar(e) {\r\n    return {\r\n        regex: e,\r\n        deser: ([e]) => e\r\n    }\r\n}\r\nconst or = {\r\n    year: {\r\n        \"2-digit\": \"yy\",\r\n        numeric: \"yyyyy\"\r\n    },\r\n    month: {\r\n        numeric: \"M\",\r\n        \"2-digit\": \"MM\",\r\n        short: \"MMM\",\r\n        long: \"MMMM\"\r\n    },\r\n    day: {\r\n        numeric: \"d\",\r\n        \"2-digit\": \"dd\"\r\n    },\r\n    weekday: {\r\n        short: \"EEE\",\r\n        long: \"EEEE\"\r\n    },\r\n    dayperiod: \"a\",\r\n    dayPeriod: \"a\",\r\n    hour: {\r\n        numeric: \"h\",\r\n        \"2-digit\": \"hh\"\r\n    },\r\n    minute: {\r\n        numeric: \"m\",\r\n        \"2-digit\": \"mm\"\r\n    },\r\n    second: {\r\n        numeric: \"s\",\r\n        \"2-digit\": \"ss\"\r\n    }\r\n};\r\nlet ur = null;\r\n\r\nfunction lr(e, t) {\r\n    if (e.literal) return e;\r\n    const r = pe.macroTokenToFormatOpts(e.val);\r\n    if (!r) return e;\r\n    const n = pe.create(t, r),\r\n        s = n.formatDateTimeParts((ur = ur || Wr.fromMillis(1555555555555), ur)),\r\n        i = s.map(e => function (e, t) {\r\n            var {\r\n                type: r,\r\n                value: e\r\n            } = e;\r\n            if (\"literal\" === r) return {\r\n                literal: !0,\r\n                val: e\r\n            };\r\n            t = t[r];\r\n            let n = or[r];\r\n            return \"object\" == typeof n && (n = n[t]), n ? {\r\n                literal: !1,\r\n                val: n\r\n            } : void 0\r\n        }(e, r));\r\n    return i.includes(void 0) ? e : i\r\n}\r\n\r\nfunction cr(t, e, r) {\r\n    const n = (l = pe.parseFormat(r), a = t, Array.prototype.concat(...l.map(e => lr(e, a)))),\r\n        s = n.map(e => function (t, r) {\r\n            const n = Qt(r),\r\n                s = Qt(r, \"{2}\"),\r\n                i = Qt(r, \"{3}\"),\r\n                a = Qt(r, \"{4}\"),\r\n                o = Qt(r, \"{6}\"),\r\n                u = Qt(r, \"{1,2}\"),\r\n                l = Qt(r, \"{1,3}\"),\r\n                c = Qt(r, \"{1,6}\"),\r\n                h = Qt(r, \"{1,9}\"),\r\n                d = Qt(r, \"{2,4}\"),\r\n                m = Qt(r, \"{4,6}\"),\r\n                f = e => ({\r\n                    regex: RegExp(e.val.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\")),\r\n                    deser: ([e]) => e,\r\n                    literal: !0\r\n                }),\r\n                e = (e => {\r\n                    if (t.literal) return f(e);\r\n                    switch (e.val) {\r\n                        case \"G\":\r\n                            return sr(r.eras(\"short\", !1), 0);\r\n                        case \"GG\":\r\n                            return sr(r.eras(\"long\", !1), 0);\r\n                        case \"y\":\r\n                            return Xt(c);\r\n                        case \"yy\":\r\n                            return Xt(d, G);\r\n                        case \"yyyy\":\r\n                            return Xt(a);\r\n                        case \"yyyyy\":\r\n                            return Xt(m);\r\n                        case \"yyyyyy\":\r\n                            return Xt(o);\r\n                        case \"M\":\r\n                            return Xt(u);\r\n                        case \"MM\":\r\n                            return Xt(s);\r\n                        case \"MMM\":\r\n                            return sr(r.months(\"short\", !0, !1), 1);\r\n                        case \"MMMM\":\r\n                            return sr(r.months(\"long\", !0, !1), 1);\r\n                        case \"L\":\r\n                            return Xt(u);\r\n                        case \"LL\":\r\n                            return Xt(s);\r\n                        case \"LLL\":\r\n                            return sr(r.months(\"short\", !1, !1), 1);\r\n                        case \"LLLL\":\r\n                            return sr(r.months(\"long\", !1, !1), 1);\r\n                        case \"d\":\r\n                            return Xt(u);\r\n                        case \"dd\":\r\n                            return Xt(s);\r\n                        case \"o\":\r\n                            return Xt(l);\r\n                        case \"ooo\":\r\n                            return Xt(i);\r\n                        case \"HH\":\r\n                            return Xt(s);\r\n                        case \"H\":\r\n                            return Xt(u);\r\n                        case \"hh\":\r\n                            return Xt(s);\r\n                        case \"h\":\r\n                            return Xt(u);\r\n                        case \"mm\":\r\n                            return Xt(s);\r\n                        case \"m\":\r\n                        case \"q\":\r\n                            return Xt(u);\r\n                        case \"qq\":\r\n                            return Xt(s);\r\n                        case \"s\":\r\n                            return Xt(u);\r\n                        case \"ss\":\r\n                            return Xt(s);\r\n                        case \"S\":\r\n                            return Xt(l);\r\n                        case \"SSS\":\r\n                            return Xt(i);\r\n                        case \"u\":\r\n                            return ar(h);\r\n                        case \"a\":\r\n                            return sr(r.meridiems(), 0);\r\n                        case \"kkkk\":\r\n                            return Xt(a);\r\n                        case \"kk\":\r\n                            return Xt(d, G);\r\n                        case \"W\":\r\n                            return Xt(u);\r\n                        case \"WW\":\r\n                            return Xt(s);\r\n                        case \"E\":\r\n                        case \"c\":\r\n                            return Xt(n);\r\n                        case \"EEE\":\r\n                            return sr(r.weekdays(\"short\", !1, !1), 1);\r\n                        case \"EEEE\":\r\n                            return sr(r.weekdays(\"long\", !1, !1), 1);\r\n                        case \"ccc\":\r\n                            return sr(r.weekdays(\"short\", !0, !1), 1);\r\n                        case \"cccc\":\r\n                            return sr(r.weekdays(\"long\", !0, !1), 1);\r\n                        case \"Z\":\r\n                        case \"ZZ\":\r\n                            return ir(new RegExp(`([+-]${u.source})(?::(${s.source}))?`), 2);\r\n                        case \"ZZZ\":\r\n                            return ir(new RegExp(`([+-]${u.source})(${s.source})?`), 2);\r\n                        case \"z\":\r\n                            return ar(/[a-z_+-/]{1,256}?/i);\r\n                        default:\r\n                            return f(e)\r\n                    }\r\n                })(t) || {\r\n                    invalidReason: Kt\r\n                };\r\n            return e.token = t, e\r\n        }(e, t)),\r\n        i = s.find(e => e.invalidReason);\r\n    var a;\r\n    if (i) return {\r\n        input: e,\r\n        tokens: n,\r\n        invalidReason: i.invalidReason\r\n    };\r\n    var [o, u] = [`^${(c=s).map(e=>e.regex).reduce((e,t)=>`${e}(${t.source})`,\"\")}$`, c], r = RegExp(o, \"i\"), [l, c] = function (e, t, r) {\r\n        const n = e.match(t);\r\n        if (n) {\r\n            const s = {};\r\n            let e = 1;\r\n            for (const i in r)\r\n                if (q(r, i)) {\r\n                    const a = r[i],\r\n                        o = a.groups ? a.groups + 1 : 1;\r\n                    !a.literal && a.token && (s[a.token.val[0]] = a.deser(n.slice(e, e + o))), e += o\r\n                } return [n, s]\r\n        }\r\n        return [n, {}]\r\n    }(e, r, u), [o, u] = c ? function (n) {\r\n        let e;\r\n        return e = $(n.Z) ? $(n.z) ? null : De.create(n.z) : new Ve(n.Z), $(n.q) || (n.M = 3 * (n.q - 1) + 1), $(n.h) || (n.h < 12 && 1 === n.a ? n.h += 12 : 12 === n.h && 0 === n.a && (n.h = 0)), 0 === n.G && n.y && (n.y = -n.y), $(n.u) || (n.S = U(n.u)), [Object.keys(n).reduce((e, t) => {\r\n            var r = (e => {\r\n                switch (e) {\r\n                    case \"S\":\r\n                        return \"millisecond\";\r\n                    case \"s\":\r\n                        return \"second\";\r\n                    case \"m\":\r\n                        return \"minute\";\r\n                    case \"h\":\r\n                    case \"H\":\r\n                        return \"hour\";\r\n                    case \"d\":\r\n                        return \"day\";\r\n                    case \"o\":\r\n                        return \"ordinal\";\r\n                    case \"L\":\r\n                    case \"M\":\r\n                        return \"month\";\r\n                    case \"y\":\r\n                        return \"year\";\r\n                    case \"E\":\r\n                    case \"c\":\r\n                        return \"weekday\";\r\n                    case \"W\":\r\n                        return \"weekNumber\";\r\n                    case \"k\":\r\n                        return \"weekYear\";\r\n                    case \"q\":\r\n                        return \"quarter\";\r\n                    default:\r\n                        return null\r\n                }\r\n            })(t);\r\n            return r && (e[r] = n[t]), e\r\n        }, {}), e]\r\n    }(c) : [null, null];\r\n    if (q(c, \"a\") && q(c, \"H\")) throw new N(\"Can't include meridiem when specifying 24-hour format\");\r\n    return {\r\n        input: e,\r\n        tokens: n,\r\n        regex: r,\r\n        rawMatches: l,\r\n        matches: c,\r\n        result: o,\r\n        zone: u\r\n    }\r\n}\r\nconst hr = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\r\n    dr = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];\r\n\r\nfunction mr(e, t) {\r\n    return new ve(\"unit out of range\", `you specified ${t} (of type ${typeof t}) as a ${e}, which is invalid`)\r\n}\r\n\r\nfunction fr(e, t, r) {\r\n    r = new Date(Date.UTC(e, t - 1, r)).getUTCDay();\r\n    return 0 === r ? 7 : r\r\n}\r\n\r\nfunction yr(e, t, r) {\r\n    return r + (W(e) ? dr : hr)[t - 1]\r\n}\r\n\r\nfunction gr(e, t) {\r\n    const r = W(e) ? dr : hr,\r\n        n = r.findIndex(e => e < t),\r\n        s = t - r[n];\r\n    return {\r\n        month: n + 1,\r\n        day: s\r\n    }\r\n}\r\n\r\nfunction wr(e) {\r\n    var {\r\n        year: t,\r\n        month: r,\r\n        day: n\r\n    } = e, s = yr(t, r, n), n = fr(t, r, n);\r\n    let i = Math.floor((s - n + 10) / 7),\r\n        a;\r\n    return i < 1 ? (a = t - 1, i = Y(a)) : i > Y(t) ? (a = t + 1, i = 1) : a = t, {\r\n        weekYear: a,\r\n        weekNumber: i,\r\n        weekday: n,\r\n        ...te(e)\r\n    }\r\n}\r\n\r\nfunction pr(e) {\r\n    var {\r\n        weekYear: t,\r\n        weekNumber: r,\r\n        weekday: n\r\n    } = e, s = fr(t, 1, 4), i = R(t);\r\n    let a = 7 * r + n - s - 3,\r\n        o;\r\n    a < 1 ? (o = t - 1, a += R(o)) : a > i ? (o = t + 1, a -= R(t)) : o = t;\r\n    var {\r\n        month: i,\r\n        day: t\r\n    } = gr(o, a);\r\n    return {\r\n        year: o,\r\n        month: i,\r\n        day: t,\r\n        ...te(e)\r\n    }\r\n}\r\n\r\nfunction vr(e) {\r\n    var {\r\n        year: t,\r\n        month: r,\r\n        day: n\r\n    } = e;\r\n    return {\r\n        year: t,\r\n        ordinal: yr(t, r, n),\r\n        ...te(e)\r\n    }\r\n}\r\n\r\nfunction Tr(e) {\r\n    var {\r\n        year: t,\r\n        ordinal: r\r\n    } = e, {\r\n        month: n,\r\n        day: r\r\n    } = gr(t, r);\r\n    return {\r\n        year: t,\r\n        month: n,\r\n        day: r,\r\n        ...te(e)\r\n    }\r\n}\r\n\r\nfunction Sr(e) {\r\n    var t = F(e.year),\r\n        r = A(e.month, 1, 12),\r\n        n = A(e.day, 1, P(e.year, e.month));\r\n    return t ? r ? !n && mr(\"day\", e.day) : mr(\"month\", e.month) : mr(\"year\", e.year)\r\n}\r\n\r\nfunction Or(e) {\r\n    var {\r\n        hour: t,\r\n        minute: r,\r\n        second: n,\r\n        millisecond: s\r\n    } = e, i = A(t, 0, 23) || 24 === t && 0 === r && 0 === n && 0 === s, a = A(r, 0, 59), o = A(n, 0, 59), e = A(s, 0, 999);\r\n    return i ? a ? o ? !e && mr(\"millisecond\", s) : mr(\"second\", n) : mr(\"minute\", r) : mr(\"hour\", t)\r\n}\r\nconst br = \"Invalid DateTime\";\r\n\r\nfunction Mr(e) {\r\n    return new ve(\"unsupported zone\", `the zone \"${e.name}\" is not supported`)\r\n}\r\n\r\nfunction kr(e) {\r\n    return null === e.weekData && (e.weekData = wr(e.c)), e.weekData\r\n}\r\n\r\nfunction Nr(e, t) {\r\n    e = {\r\n        ts: e.ts,\r\n        zone: e.zone,\r\n        c: e.c,\r\n        o: e.o,\r\n        loc: e.loc,\r\n        invalid: e.invalid\r\n    };\r\n    return new Wr({\r\n        ...e,\r\n        ...t,\r\n        old: e\r\n    })\r\n}\r\n\r\nfunction Dr(e, t, r) {\r\n    let n = e - 60 * t * 1e3;\r\n    var s = r.offset(n);\r\n    if (t === s) return [n, t];\r\n    n -= 60 * (s - t) * 1e3;\r\n    r = r.offset(n);\r\n    return s === r ? [n, s] : [e - 60 * Math.min(s, r) * 1e3, Math.max(s, r)]\r\n}\r\n\r\nfunction Er(e, t) {\r\n    e += 60 * t * 1e3;\r\n    const r = new Date(e);\r\n    return {\r\n        year: r.getUTCFullYear(),\r\n        month: r.getUTCMonth() + 1,\r\n        day: r.getUTCDate(),\r\n        hour: r.getUTCHours(),\r\n        minute: r.getUTCMinutes(),\r\n        second: r.getUTCSeconds(),\r\n        millisecond: r.getUTCMilliseconds()\r\n    }\r\n}\r\n\r\nfunction Vr(e, t, r) {\r\n    return Dr(J(e), t, r)\r\n}\r\n\r\nfunction Ir(e, t) {\r\n    var r = e.o,\r\n        n = e.c.year + Math.trunc(t.years),\r\n        s = e.c.month + Math.trunc(t.months) + 3 * Math.trunc(t.quarters),\r\n        s = {\r\n            ...e.c,\r\n            year: n,\r\n            month: s,\r\n            day: Math.min(e.c.day, P(n, s)) + Math.trunc(t.days) + 7 * Math.trunc(t.weeks)\r\n        },\r\n        t = _t.fromObject({\r\n            years: t.years - Math.trunc(t.years),\r\n            quarters: t.quarters - Math.trunc(t.quarters),\r\n            months: t.months - Math.trunc(t.months),\r\n            weeks: t.weeks - Math.trunc(t.weeks),\r\n            days: t.days - Math.trunc(t.days),\r\n            hours: t.hours,\r\n            minutes: t.minutes,\r\n            seconds: t.seconds,\r\n            milliseconds: t.milliseconds\r\n        }).as(\"milliseconds\");\r\n    let [i, a] = Dr(J(s), r, e.zone);\r\n    return 0 !== t && (i += t, a = e.zone.offset(i)), {\r\n        ts: i,\r\n        o: a\r\n    }\r\n}\r\n\r\nfunction xr(e, t, r, n, s) {\r\n    var {\r\n        setZone: i,\r\n        zone: a\r\n    } = r;\r\n    if (e && 0 !== Object.keys(e).length) {\r\n        const o = t || a,\r\n            u = Wr.fromObject(e, {\r\n                ...r,\r\n                zone: o\r\n            });\r\n        return i ? u : u.setZone(a)\r\n    }\r\n    return Wr.invalid(new ve(\"unparsable\", `the input \"${s}\" can't be parsed as ${n}`))\r\n}\r\n\r\nfunction Cr(e, t, r = !0) {\r\n    return e.isValid ? pe.create(Ye.create(\"en-US\"), {\r\n        allowZ: r,\r\n        forceSimple: !0\r\n    }).formatDateTimeFromString(e, t) : null\r\n}\r\n\r\nfunction $r(e, {\r\n    suppressSeconds: t = !1,\r\n    suppressMilliseconds: r = !1,\r\n    includeOffset: n,\r\n    includePrefix: s = !1,\r\n    includeZone: i = !1,\r\n    spaceZone: a = !1,\r\n    format: o = \"extended\"\r\n}) {\r\n    let u = \"basic\" === o ? \"HHmm\" : \"HH:mm\";\r\n    t && 0 === e.second && 0 === e.millisecond || (u += \"basic\" === o ? \"ss\" : \":ss\", r && 0 === e.millisecond || (u += \".SSS\")), (i || n) && a && (u += \" \"), i ? u += \"z\" : n && (u += \"basic\" === o ? \"ZZZ\" : \"ZZ\");\r\n    let l = Cr(e, u);\r\n    return s && (l = \"T\" + l), l\r\n}\r\nconst Zr = {\r\n        month: 1,\r\n        day: 1,\r\n        hour: 0,\r\n        minute: 0,\r\n        second: 0,\r\n        millisecond: 0\r\n    },\r\n    Fr = {\r\n        weekNumber: 1,\r\n        weekday: 1,\r\n        hour: 0,\r\n        minute: 0,\r\n        second: 0,\r\n        millisecond: 0\r\n    },\r\n    Lr = {\r\n        ordinal: 1,\r\n        hour: 0,\r\n        minute: 0,\r\n        second: 0,\r\n        millisecond: 0\r\n    },\r\n    zr = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"millisecond\"],\r\n    qr = [\"weekYear\", \"weekNumber\", \"weekday\", \"hour\", \"minute\", \"second\", \"millisecond\"],\r\n    Ar = [\"year\", \"ordinal\", \"hour\", \"minute\", \"second\", \"millisecond\"];\r\n\r\nfunction jr(e) {\r\n    var t = {\r\n        year: \"year\",\r\n        years: \"year\",\r\n        month: \"month\",\r\n        months: \"month\",\r\n        day: \"day\",\r\n        days: \"day\",\r\n        hour: \"hour\",\r\n        hours: \"hour\",\r\n        minute: \"minute\",\r\n        minutes: \"minute\",\r\n        quarter: \"quarter\",\r\n        quarters: \"quarter\",\r\n        second: \"second\",\r\n        seconds: \"second\",\r\n        millisecond: \"millisecond\",\r\n        milliseconds: \"millisecond\",\r\n        weekday: \"weekday\",\r\n        weekdays: \"weekday\",\r\n        weeknumber: \"weekNumber\",\r\n        weeksnumber: \"weekNumber\",\r\n        weeknumbers: \"weekNumber\",\r\n        weekyear: \"weekYear\",\r\n        weekyears: \"weekYear\",\r\n        ordinal: \"ordinal\"\r\n    } [e.toLowerCase()];\r\n    if (!t) throw new i(e);\r\n    return t\r\n}\r\n\r\nfunction _r(e, t) {\r\n    const r = xe(t.zone, qe.defaultZone),\r\n        n = Ye.fromObject(t),\r\n        s = qe.now();\r\n    let i, a;\r\n    if ($(e.year)) i = s;\r\n    else {\r\n        for (const o of zr) $(e[o]) && (e[o] = Zr[o]);\r\n        t = Sr(e) || Or(e);\r\n        if (t) return Wr.invalid(t);\r\n        t = r.offset(s);\r\n        [i, a] = Vr(e, t, r)\r\n    }\r\n    return new Wr({\r\n        ts: i,\r\n        zone: r,\r\n        loc: n,\r\n        o: a\r\n    })\r\n}\r\n\r\nfunction Ur(t, n, s) {\r\n    const i = !!$(s.round) || s.round,\r\n        e = (e, t) => {\r\n            e = H(e, i || s.calendary ? 0 : 2, !0);\r\n            const r = n.loc.clone(s).relFormatter(s);\r\n            return r.format(e, t)\r\n        },\r\n        r = e => s.calendary ? n.hasSame(t, e) ? 0 : n.startOf(e).diff(t.startOf(e), e).get(e) : n.diff(t, e).get(e);\r\n    if (s.unit) return e(r(s.unit), s.unit);\r\n    for (const o of s.units) {\r\n        var a = r(o);\r\n        if (1 <= Math.abs(a)) return e(a, o)\r\n    }\r\n    return e(n < t ? -0 : 0, s.units[s.units.length - 1])\r\n}\r\n\r\nfunction Hr(e) {\r\n    let t = {},\r\n        r;\r\n    return r = 0 < e.length && \"object\" == typeof e[e.length - 1] ? (t = e[e.length - 1], Array.from(e).slice(0, e.length - 1)) : Array.from(e), [t, r]\r\n}\r\nclass Wr {\r\n    constructor(e) {\r\n        const t = e.zone || qe.defaultZone;\r\n        let r = e.invalid || (Number.isNaN(e.ts) ? new ve(\"invalid input\") : null) || (t.isValid ? null : Mr(t));\r\n        this.ts = $(e.ts) ? qe.now() : e.ts;\r\n        let n = null,\r\n            s = null;\r\n        var i;\r\n        r || (e.old && e.old.ts === this.ts && e.old.zone.equals(t) ? [n, s] = [e.old.c, e.old.o] : (i = t.offset(this.ts), n = Er(this.ts, i), r = Number.isNaN(n.year) ? new ve(\"invalid input\") : null, n = r ? null : n, s = r ? null : i)), this._zone = t, this.loc = e.loc || Ye.create(), this.invalid = r, this.weekData = null, this.c = n, this.o = s, this.isLuxonDateTime = !0\r\n    }\r\n    static now() {\r\n        return new Wr({})\r\n    }\r\n    static local() {\r\n        var [e, t] = Hr(arguments), [r, n, s, i, a, o, t] = t;\r\n        return _r({\r\n            year: r,\r\n            month: n,\r\n            day: s,\r\n            hour: i,\r\n            minute: a,\r\n            second: o,\r\n            millisecond: t\r\n        }, e)\r\n    }\r\n    static utc() {\r\n        const [e, t] = Hr(arguments), [r, n, s, i, a, o, u] = t;\r\n        return e.zone = Ve.utcInstance, _r({\r\n            year: r,\r\n            month: n,\r\n            day: s,\r\n            hour: i,\r\n            minute: a,\r\n            second: o,\r\n            millisecond: u\r\n        }, e)\r\n    }\r\n    static fromJSDate(e, t = {}) {\r\n        var r = \"[object Date]\" === Object.prototype.toString.call(e) ? e.valueOf() : NaN;\r\n        if (Number.isNaN(r)) return Wr.invalid(\"invalid input\");\r\n        e = xe(t.zone, qe.defaultZone);\r\n        return e.isValid ? new Wr({\r\n            ts: r,\r\n            zone: e,\r\n            loc: Ye.fromObject(t)\r\n        }) : Wr.invalid(Mr(e))\r\n    }\r\n    static fromMillis(e, t = {}) {\r\n        if (Z(e)) return e < -864e13 || 864e13 < e ? Wr.invalid(\"Timestamp out of range\") : new Wr({\r\n            ts: e,\r\n            zone: xe(t.zone, qe.defaultZone),\r\n            loc: Ye.fromObject(t)\r\n        });\r\n        throw new a(`fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`)\r\n    }\r\n    static fromSeconds(e, t = {}) {\r\n        if (Z(e)) return new Wr({\r\n            ts: 1e3 * e,\r\n            zone: xe(t.zone, qe.defaultZone),\r\n            loc: Ye.fromObject(t)\r\n        });\r\n        throw new a(\"fromSeconds requires a numerical input\")\r\n    }\r\n    static fromObject(e, t = {}) {\r\n        e = e || {};\r\n        const r = xe(t.zone, qe.defaultZone);\r\n        if (!r.isValid) return Wr.invalid(Mr(r));\r\n        const n = qe.now(),\r\n            s = r.offset(n),\r\n            i = X(e, jr),\r\n            a = !$(i.ordinal),\r\n            o = !$(i.year),\r\n            u = !$(i.month) || !$(i.day),\r\n            l = o || u,\r\n            c = i.weekYear || i.weekNumber,\r\n            h = Ye.fromObject(t);\r\n        if ((l || a) && c) throw new N(\"Can't mix weekYear/weekNumber units with year/month/day or ordinals\");\r\n        if (u && a) throw new N(\"Can't mix ordinal dates with month/day\");\r\n        var d = c || i.weekday && !l;\r\n        let m, f, y = Er(n, s);\r\n        d ? (m = qr, f = Fr, y = wr(y)) : a ? (m = Ar, f = Lr, y = vr(y)) : (m = zr, f = Zr);\r\n        let g = !1;\r\n        for (const k of m) $(i[k]) ? g ? i[k] = f[k] : i[k] = y[k] : g = !0;\r\n        var w, p, v, T, w = (d ? (p = i, v = F(p.weekYear), t = A(p.weekNumber, 1, Y(p.weekYear)), T = A(p.weekday, 1, 7), v ? t ? !T && mr(\"weekday\", p.weekday) : mr(\"week\", p.week) : mr(\"weekYear\", p.weekYear)) : a ? (w = i, T = F(w.year), p = A(w.ordinal, 1, R(w.year)), T ? !p && mr(\"ordinal\", w.ordinal) : mr(\"year\", w.year)) : Sr(i)) || Or(i);\r\n        if (w) return Wr.invalid(w);\r\n        const S = d ? pr(i) : a ? Tr(i) : i,\r\n            [O, b] = Vr(S, s, r),\r\n            M = new Wr({\r\n                ts: O,\r\n                zone: r,\r\n                o: b,\r\n                loc: h\r\n            });\r\n        return i.weekday && l && e.weekday !== M.weekday ? Wr.invalid(\"mismatched weekday\", `you can't specify both a weekday of ${i.weekday} and a date of ${M.toISO()}`) : M\r\n    }\r\n    static fromISO(e, t = {}) {\r\n        var [r, n] = Qe(e, [vt, bt], [Tt, Mt], [St, kt], [Ot, Nt]);\r\n        return xr(r, n, t, \"ISO 8601\", e)\r\n    }\r\n    static fromRFC2822(e, t = {}) {\r\n        var [r, n] = Qe(e.replace(/\\([^)]*\\)|[\\n\\t]/g, \" \").replace(/(\\s\\s+)/g, \" \").trim(), [dt, mt]);\r\n        return xr(r, n, t, \"RFC 2822\", e)\r\n    }\r\n    static fromHTTP(e, t = {}) {\r\n        var [r, e] = Qe(e, [ft, wt], [yt, wt], [gt, pt]);\r\n        return xr(r, e, t, \"HTTP\", t)\r\n    }\r\n    static fromFormat(e, t, r = {}) {\r\n        if ($(e) || $(t)) throw new a(\"fromFormat requires an input string and a format\");\r\n        var {\r\n            locale: n = null,\r\n            numberingSystem: s = null\r\n        } = r, [i, n, s] = function (e, t, r) {\r\n            var {\r\n                result: e,\r\n                zone: t,\r\n                invalidReason: r\r\n            } = cr(e, t, r);\r\n            return [e, t, r]\r\n        }(Ye.fromOpts({\r\n            locale: n,\r\n            numberingSystem: s,\r\n            defaultToEN: !0\r\n        }), e, t);\r\n        return s ? Wr.invalid(s) : xr(i, n, r, `format ${t}`, e)\r\n    }\r\n    static fromString(e, t, r = {}) {\r\n        return Wr.fromFormat(e, t, r)\r\n    }\r\n    static fromSQL(e, t = {}) {\r\n        var [r, n] = Qe(e, [Et, It], [Vt, xt]);\r\n        return xr(r, n, t, \"SQL\", e)\r\n    }\r\n    static invalid(e, t = null) {\r\n        if (!e) throw new a(\"need to specify a reason the DateTime is invalid\");\r\n        t = e instanceof ve ? e : new ve(e, t);\r\n        if (qe.throwOnInvalid) throw new r(t);\r\n        return new Wr({\r\n            invalid: t\r\n        })\r\n    }\r\n    static isDateTime(e) {\r\n        return e && e.isLuxonDateTime || !1\r\n    }\r\n    get(e) {\r\n        return this[e]\r\n    }\r\n    get isValid() {\r\n        return null === this.invalid\r\n    }\r\n    get invalidReason() {\r\n        return this.invalid ? this.invalid.reason : null\r\n    }\r\n    get invalidExplanation() {\r\n        return this.invalid ? this.invalid.explanation : null\r\n    }\r\n    get locale() {\r\n        return this.isValid ? this.loc.locale : null\r\n    }\r\n    get numberingSystem() {\r\n        return this.isValid ? this.loc.numberingSystem : null\r\n    }\r\n    get outputCalendar() {\r\n        return this.isValid ? this.loc.outputCalendar : null\r\n    }\r\n    get zone() {\r\n        return this._zone\r\n    }\r\n    get zoneName() {\r\n        return this.isValid ? this.zone.name : null\r\n    }\r\n    get year() {\r\n        return this.isValid ? this.c.year : NaN\r\n    }\r\n    get quarter() {\r\n        return this.isValid ? Math.ceil(this.c.month / 3) : NaN\r\n    }\r\n    get month() {\r\n        return this.isValid ? this.c.month : NaN\r\n    }\r\n    get day() {\r\n        return this.isValid ? this.c.day : NaN\r\n    }\r\n    get hour() {\r\n        return this.isValid ? this.c.hour : NaN\r\n    }\r\n    get minute() {\r\n        return this.isValid ? this.c.minute : NaN\r\n    }\r\n    get second() {\r\n        return this.isValid ? this.c.second : NaN\r\n    }\r\n    get millisecond() {\r\n        return this.isValid ? this.c.millisecond : NaN\r\n    }\r\n    get weekYear() {\r\n        return this.isValid ? kr(this).weekYear : NaN\r\n    }\r\n    get weekNumber() {\r\n        return this.isValid ? kr(this).weekNumber : NaN\r\n    }\r\n    get weekday() {\r\n        return this.isValid ? kr(this).weekday : NaN\r\n    }\r\n    get ordinal() {\r\n        return this.isValid ? vr(this.c).ordinal : NaN\r\n    }\r\n    get monthShort() {\r\n        return this.isValid ? Rt.months(\"short\", {\r\n            locObj: this.loc\r\n        })[this.month - 1] : null\r\n    }\r\n    get monthLong() {\r\n        return this.isValid ? Rt.months(\"long\", {\r\n            locObj: this.loc\r\n        })[this.month - 1] : null\r\n    }\r\n    get weekdayShort() {\r\n        return this.isValid ? Rt.weekdays(\"short\", {\r\n            locObj: this.loc\r\n        })[this.weekday - 1] : null\r\n    }\r\n    get weekdayLong() {\r\n        return this.isValid ? Rt.weekdays(\"long\", {\r\n            locObj: this.loc\r\n        })[this.weekday - 1] : null\r\n    }\r\n    get offset() {\r\n        return this.isValid ? +this.o : NaN\r\n    }\r\n    get offsetNameShort() {\r\n        return this.isValid ? this.zone.offsetName(this.ts, {\r\n            format: \"short\",\r\n            locale: this.locale\r\n        }) : null\r\n    }\r\n    get offsetNameLong() {\r\n        return this.isValid ? this.zone.offsetName(this.ts, {\r\n            format: \"long\",\r\n            locale: this.locale\r\n        }) : null\r\n    }\r\n    get isOffsetFixed() {\r\n        return this.isValid ? this.zone.isUniversal : null\r\n    }\r\n    get isInDST() {\r\n        return !this.isOffsetFixed && (this.offset > this.set({\r\n            month: 1\r\n        }).offset || this.offset > this.set({\r\n            month: 5\r\n        }).offset)\r\n    }\r\n    get isInLeapYear() {\r\n        return W(this.year)\r\n    }\r\n    get daysInMonth() {\r\n        return P(this.year, this.month)\r\n    }\r\n    get daysInYear() {\r\n        return this.isValid ? R(this.year) : NaN\r\n    }\r\n    get weeksInWeekYear() {\r\n        return this.isValid ? Y(this.weekYear) : NaN\r\n    }\r\n    resolvedLocaleOptions(e = {}) {\r\n        var {\r\n            locale: t,\r\n            numberingSystem: r,\r\n            calendar: e\r\n        } = pe.create(this.loc.clone(e), e).resolvedOptions(this);\r\n        return {\r\n            locale: t,\r\n            numberingSystem: r,\r\n            outputCalendar: e\r\n        }\r\n    }\r\n    toUTC(e = 0, t = {}) {\r\n        return this.setZone(Ve.instance(e), t)\r\n    }\r\n    toLocal() {\r\n        return this.setZone(qe.defaultZone)\r\n    }\r\n    setZone(t, {\r\n        keepLocalTime: r = !1,\r\n        keepCalendarTime: n = !1\r\n    } = {}) {\r\n        if ((t = xe(t, qe.defaultZone)).equals(this.zone)) return this;\r\n        if (t.isValid) {\r\n            let e = this.ts;\r\n            return (r || n) && (r = t.offset(this.ts), n = this.toObject(), [e] = Vr(n, r, t)), Nr(this, {\r\n                ts: e,\r\n                zone: t\r\n            })\r\n        }\r\n        return Wr.invalid(Mr(t))\r\n    }\r\n    reconfigure({\r\n        locale: e,\r\n        numberingSystem: t,\r\n        outputCalendar: r\r\n    } = {}) {\r\n        r = this.loc.clone({\r\n            locale: e,\r\n            numberingSystem: t,\r\n            outputCalendar: r\r\n        });\r\n        return Nr(this, {\r\n            loc: r\r\n        })\r\n    }\r\n    setLocale(e) {\r\n        return this.reconfigure({\r\n            locale: e\r\n        })\r\n    }\r\n    set(e) {\r\n        if (!this.isValid) return this;\r\n        var t = X(e, jr),\r\n            r = !$(t.weekYear) || !$(t.weekNumber) || !$(t.weekday),\r\n            n = !$(t.ordinal),\r\n            s = !$(t.year),\r\n            i = !$(t.month) || !$(t.day),\r\n            e = t.weekYear || t.weekNumber;\r\n        if ((s || i || n) && e) throw new N(\"Can't mix weekYear/weekNumber units with year/month/day or ordinals\");\r\n        if (i && n) throw new N(\"Can't mix ordinal dates with month/day\");\r\n        let a;\r\n        r ? a = pr({\r\n            ...wr(this.c),\r\n            ...t\r\n        }) : $(t.ordinal) ? (a = {\r\n            ...this.toObject(),\r\n            ...t\r\n        }, $(t.day) && (a.day = Math.min(P(a.year, a.month), a.day))) : a = Tr({\r\n            ...vr(this.c),\r\n            ...t\r\n        });\r\n        var [r, t] = Vr(a, this.o, this.zone);\r\n        return Nr(this, {\r\n            ts: r,\r\n            o: t\r\n        })\r\n    }\r\n    plus(e) {\r\n        return this.isValid ? Nr(this, Ir(this, Ut(e))) : this\r\n    }\r\n    minus(e) {\r\n        return this.isValid ? Nr(this, Ir(this, Ut(e).negate())) : this\r\n    }\r\n    startOf(e) {\r\n        if (!this.isValid) return this;\r\n        const t = {},\r\n            r = _t.normalizeUnit(e);\r\n        switch (r) {\r\n            case \"years\":\r\n                t.month = 1;\r\n            case \"quarters\":\r\n            case \"months\":\r\n                t.day = 1;\r\n            case \"weeks\":\r\n            case \"days\":\r\n                t.hour = 0;\r\n            case \"hours\":\r\n                t.minute = 0;\r\n            case \"minutes\":\r\n                t.second = 0;\r\n            case \"seconds\":\r\n                t.millisecond = 0\r\n        }\r\n        return \"weeks\" === r && (t.weekday = 1), \"quarters\" === r && (e = Math.ceil(this.month / 3), t.month = 3 * (e - 1) + 1), this.set(t)\r\n    }\r\n    endOf(e) {\r\n        return this.isValid ? this.plus({\r\n            [e]: 1\r\n        }).startOf(e).minus(1) : this\r\n    }\r\n    toFormat(e, t = {}) {\r\n        return this.isValid ? pe.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this, e) : br\r\n    }\r\n    toLocaleString(e = c, t = {}) {\r\n        return this.isValid ? pe.create(this.loc.clone(t), e).formatDateTime(this) : br\r\n    }\r\n    toLocaleParts(e = {}) {\r\n        return this.isValid ? pe.create(this.loc.clone(e), e).formatDateTimeParts(this) : []\r\n    }\r\n    toISO(e = {}) {\r\n        return this.isValid ? `${this.toISODate(e)}T${this.toISOTime(e)}` : null\r\n    }\r\n    toISODate({\r\n        format: e = \"extended\"\r\n    } = {}) {\r\n        let t = \"basic\" === e ? \"yyyyMMdd\" : \"yyyy-MM-dd\";\r\n        return 9999 < this.year && (t = \"+\" + t), Cr(this, t)\r\n    }\r\n    toISOWeekDate() {\r\n        return Cr(this, \"kkkk-'W'WW-c\")\r\n    }\r\n    toISOTime({\r\n        suppressMilliseconds: e = !1,\r\n        suppressSeconds: t = !1,\r\n        includeOffset: r = !0,\r\n        includePrefix: n = !1,\r\n        format: s = \"extended\"\r\n    } = {}) {\r\n        return $r(this, {\r\n            suppressSeconds: t,\r\n            suppressMilliseconds: e,\r\n            includeOffset: r,\r\n            includePrefix: n,\r\n            format: s\r\n        })\r\n    }\r\n    toRFC2822() {\r\n        return Cr(this, \"EEE, dd LLL yyyy HH:mm:ss ZZZ\", !1)\r\n    }\r\n    toHTTP() {\r\n        return Cr(this.toUTC(), \"EEE, dd LLL yyyy HH:mm:ss 'GMT'\")\r\n    }\r\n    toSQLDate() {\r\n        return Cr(this, \"yyyy-MM-dd\")\r\n    }\r\n    toSQLTime({\r\n        includeOffset: e = !0,\r\n        includeZone: t = !1\r\n    } = {}) {\r\n        return $r(this, {\r\n            includeOffset: e,\r\n            includeZone: t,\r\n            spaceZone: !0\r\n        })\r\n    }\r\n    toSQL(e = {}) {\r\n        return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null\r\n    }\r\n    toString() {\r\n        return this.isValid ? this.toISO() : br\r\n    }\r\n    valueOf() {\r\n        return this.toMillis()\r\n    }\r\n    toMillis() {\r\n        return this.isValid ? this.ts : NaN\r\n    }\r\n    toSeconds() {\r\n        return this.isValid ? this.ts / 1e3 : NaN\r\n    }\r\n    toJSON() {\r\n        return this.toISO()\r\n    }\r\n    toBSON() {\r\n        return this.toJSDate()\r\n    }\r\n    toObject(e = {}) {\r\n        if (!this.isValid) return {};\r\n        const t = {\r\n            ...this.c\r\n        };\r\n        return e.includeConfig && (t.outputCalendar = this.outputCalendar, t.numberingSystem = this.loc.numberingSystem, t.locale = this.loc.locale), t\r\n    }\r\n    toJSDate() {\r\n        return new Date(this.isValid ? this.ts : NaN)\r\n    }\r\n    diff(e, t = \"milliseconds\", r = {}) {\r\n        if (!this.isValid || !e.isValid) return _t.invalid(\"created by diffing an invalid DateTime\");\r\n        r = {\r\n            locale: this.locale,\r\n            numberingSystem: this.numberingSystem,\r\n            ...r\r\n        };\r\n        const n = (t = t, (Array.isArray(t) ? t : [t]).map(_t.normalizeUnit)),\r\n            s = e.valueOf() > this.valueOf(),\r\n            i = s ? this : e,\r\n            a = s ? e : this,\r\n            o = Jt(i, a, n, r);\r\n        return s ? o.negate() : o\r\n    }\r\n    diffNow(e = \"milliseconds\", t = {}) {\r\n        return this.diff(Wr.now(), e, t)\r\n    }\r\n    until(e) {\r\n        return this.isValid ? Wt.fromDateTimes(this, e) : this\r\n    }\r\n    hasSame(e, t) {\r\n        if (!this.isValid) return !1;\r\n        var r = e.valueOf();\r\n        const n = this.setZone(e.zone, {\r\n            keepLocalTime: !0\r\n        });\r\n        return n.startOf(t) <= r && r <= n.endOf(t)\r\n    }\r\n    equals(e) {\r\n        return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc)\r\n    }\r\n    toRelative(e = {}) {\r\n        if (!this.isValid) return null;\r\n        var t = e.base || Wr.fromObject({}, {\r\n                zone: this.zone\r\n            }),\r\n            r = e.padding ? this < t ? -e.padding : e.padding : 0;\r\n        let n = [\"years\", \"months\", \"days\", \"hours\", \"minutes\", \"seconds\"],\r\n            s = e.unit;\r\n        return Array.isArray(e.unit) && (n = e.unit, s = void 0), Ur(t, this.plus(r), {\r\n            ...e,\r\n            numeric: \"always\",\r\n            units: n,\r\n            unit: s\r\n        })\r\n    }\r\n    toRelativeCalendar(e = {}) {\r\n        return this.isValid ? Ur(e.base || Wr.fromObject({}, {\r\n            zone: this.zone\r\n        }), this, {\r\n            ...e,\r\n            numeric: \"auto\",\r\n            units: [\"years\", \"months\", \"days\"],\r\n            calendary: !0\r\n        }) : null\r\n    }\r\n    static min(...e) {\r\n        if (!e.every(Wr.isDateTime)) throw new a(\"min requires all arguments be DateTimes\");\r\n        return z(e, e => e.valueOf(), Math.min)\r\n    }\r\n    static max(...e) {\r\n        if (!e.every(Wr.isDateTime)) throw new a(\"max requires all arguments be DateTimes\");\r\n        return z(e, e => e.valueOf(), Math.max)\r\n    }\r\n    static fromFormatExplain(e, t, r = {}) {\r\n        var {\r\n            locale: n = null,\r\n            numberingSystem: r = null\r\n        } = r;\r\n        return cr(Ye.fromOpts({\r\n            locale: n,\r\n            numberingSystem: r,\r\n            defaultToEN: !0\r\n        }), e, t)\r\n    }\r\n    static fromStringExplain(e, t, r = {}) {\r\n        return Wr.fromFormatExplain(e, t, r)\r\n    }\r\n    static get DATE_SHORT() {\r\n        return c\r\n    }\r\n    static get DATE_MED() {\r\n        return h\r\n    }\r\n    static get DATE_MED_WITH_WEEKDAY() {\r\n        return d\r\n    }\r\n    static get DATE_FULL() {\r\n        return m\r\n    }\r\n    static get DATE_HUGE() {\r\n        return f\r\n    }\r\n    static get TIME_SIMPLE() {\r\n        return y\r\n    }\r\n    static get TIME_WITH_SECONDS() {\r\n        return g\r\n    }\r\n    static get TIME_WITH_SHORT_OFFSET() {\r\n        return w\r\n    }\r\n    static get TIME_WITH_LONG_OFFSET() {\r\n        return p\r\n    }\r\n    static get TIME_24_SIMPLE() {\r\n        return v\r\n    }\r\n    static get TIME_24_WITH_SECONDS() {\r\n        return T\r\n    }\r\n    static get TIME_24_WITH_SHORT_OFFSET() {\r\n        return S\r\n    }\r\n    static get TIME_24_WITH_LONG_OFFSET() {\r\n        return O\r\n    }\r\n    static get DATETIME_SHORT() {\r\n        return b\r\n    }\r\n    static get DATETIME_SHORT_WITH_SECONDS() {\r\n        return M\r\n    }\r\n    static get DATETIME_MED() {\r\n        return k\r\n    }\r\n    static get DATETIME_MED_WITH_SECONDS() {\r\n        return D\r\n    }\r\n    static get DATETIME_MED_WITH_WEEKDAY() {\r\n        return E\r\n    }\r\n    static get DATETIME_FULL() {\r\n        return V\r\n    }\r\n    static get DATETIME_FULL_WITH_SECONDS() {\r\n        return I\r\n    }\r\n    static get DATETIME_HUGE() {\r\n        return x\r\n    }\r\n    static get DATETIME_HUGE_WITH_SECONDS() {\r\n        return C\r\n    }\r\n}\r\n\r\nfunction Rr(e) {\r\n    if (Wr.isDateTime(e)) return e;\r\n    if (e && e.valueOf && Z(e.valueOf())) return Wr.fromJSDate(e);\r\n    if (e && \"object\" == typeof e) return Wr.fromObject(e);\r\n    throw new a(`Unknown datetime argument: ${e}, of type ${typeof e}`)\r\n}\r\nXe = \"2.0.2\";\r\n\r\n\n\n//# sourceURL=webpack://hw2/./js/luxonSrc.js?");

/***/ }),

/***/ "./js/main.js":
/*!********************!*\
  !*** ./js/main.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../style.css */ \"./style.css\");\n/* harmony import */ var _output_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./output.js */ \"./js/output.js\");\n/* harmony import */ var _calcDatesDiff_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./calcDatesDiff.js */ \"./js/calcDatesDiff.js\");\n/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./timer.js */ \"./js/timer.js\");\n/* harmony import */ var _tabSwitch_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tabSwitch.js */ \"./js/tabSwitch.js\");\n/* harmony import */ var _tabSwitch_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_tabSwitch_js__WEBPACK_IMPORTED_MODULE_4__);\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst form = document.getElementById('calcDate');\r\n\r\nform.onsubmit = function (event){\r\n    event.preventDefault();\r\n    const formData = new FormData(event.target);\r\n    const dateFrom = formData.get('dateFrom');\r\n    const dateTo = formData.get('dateTo');\r\n\r\n  if(!dateFrom || !dateTo){\r\n    (0,_output_js__WEBPACK_IMPORTED_MODULE_1__.showError)('');\r\n\r\n    return\r\n  } else {\r\n   const datesDiff = (0,_calcDatesDiff_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(dateFrom, dateTo);\r\n   (0,_output_js__WEBPACK_IMPORTED_MODULE_1__.showResult)(datesDiff)\r\n  }\r\n};\n\n//# sourceURL=webpack://hw2/./js/main.js?");

/***/ }),

/***/ "./js/output.js":
/*!**********************!*\
  !*** ./js/output.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"showError\": () => (/* binding */ showError),\n/* harmony export */   \"showResult\": () => (/* binding */ showResult)\n/* harmony export */ });\nconst paragraph = document.getElementById('output');\r\n\r\nfunction showError (errorText){\r\n    paragraph.innerHTML = errorText;\r\n}\r\n\r\nconst showResult = ({years, months, days})=>{\r\n    paragraph.innerHTML = `\r\n   : ${years}\r\n    : ${months}\r\n    : ${days}\r\n    `\r\n}\r\n\r\n\n\n//# sourceURL=webpack://hw2/./js/output.js?");

/***/ }),

/***/ "./js/tabSwitch.js":
/*!*************************!*\
  !*** ./js/tabSwitch.js ***!
  \*************************/
/***/ (() => {

eval("var tabBtn;\r\nvar tabContent;\r\n\r\n\r\nwindow.onload=function() {\r\n    tabContent=document.getElementsByClassName('tabContent');\r\n    tabBtn=document.getElementsByClassName('tabBtn');\r\n    hideTabsContent(1);\r\n} \r\n\r\nfunction hideTabsContent(a) {\r\n    for (var i=a; i<tabContent.length; i++) {\r\n        tabContent[i].classList.remove('show');\r\n        tabContent[i].classList.add(\"hide\");\r\n        tabBtn[i].classList.remove('active');\r\n    }\r\n}\r\n\r\ndocument.getElementById('tab-links').onclick= function (event) {\r\n    var target=event.target;\r\n    if (target.className=='tabBtn') {\r\n       for (var i=0; i<tabBtn.length; i++) {\r\n           if (target == tabBtn[i]) {\r\n               showTabsContent(i);\r\n               break;\r\n}}}}\r\n\r\nfunction showTabsContent(b){\r\n    if (tabContent[b].classList.contains('hide')) {\r\n        hideTabsContent(0);\r\n        tabBtn[b].classList.add('active');\r\n        tabContent[b].classList.remove('hide');\r\n        tabContent[b].classList.add('show');\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://hw2/./js/tabSwitch.js?");

/***/ }),

/***/ "./js/timer.js":
/*!*********************!*\
  !*** ./js/timer.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _howler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./howler.js */ \"./js/howler.js\");\n \r\n//input\r\nconst minutesInput = document.getElementById('minutes');\r\nconst secondsInput = document.getElementById('seconds');\r\n\r\n//controls\r\nconst startBtn = document.getElementById('start');\r\nconst pauseBtn = document.getElementById('pause');\r\nconst resetBtn = document.getElementById('reset');\r\n//output\r\nconst minutesEl = document.getElementById('minutesEl');\r\nconst secondsEl = document.getElementById('secondsEl');\r\nconst timeCounterEl = document.getElementById('timeCounter');\r\n\r\nvar interval;\r\n\r\nstartBtn.addEventListener('click', ()=> {\r\n    let minutes = Number(minutesInput.value);\r\n    let seconds = Number(secondsInput.value);\r\n    \r\n    interval = setInterval (()=> {\r\n        minutesInput.value = minutes;\r\n        secondsInput.value = --seconds ;\r\n    \r\n        if (minutes < 10) {\r\n            minutesInput.value = `0${minutes}`;\r\n        } else {\r\n            minutesInput.value = minutes;\r\n        }\r\n    \r\n        if (seconds < 10) {\r\n            secondsInput.value = `0${seconds}`;\r\n        } else {\r\n            secondsInput.value = seconds;\r\n        }\r\n        if(seconds == 0) {\r\n            seconds = 59;\r\n            --minutes;\r\n            if(minutes < 0) {\r\n                clearInterval(interval)\r\n                _howler_js__WEBPACK_IMPORTED_MODULE_0__.sound.play();\r\n                }\r\n        } \r\n    }, 1000)\r\n\r\n});\r\n\r\npauseBtn.addEventListener ('click', ()=>{\r\n    clearInterval(interval);\r\n});\r\n\r\nresetBtn.addEventListener('click', ()=> {\r\n    clearInterval(interval);\r\n    minutesInput.value = null;\r\n    secondsInput.value = null;\r\n})\r\n\n\n//# sourceURL=webpack://hw2/./js/timer.js?");

/***/ }),

/***/ "./style.css":
/*!*******************!*\
  !*** ./style.css ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://hw2/./style.css?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./js/main.js");
/******/ 	
/******/ })()
;